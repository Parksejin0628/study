문제 : 5525번 "IOIOI" (난이도 실버2)
풀이시간 : 21분 29초
한줄평 : 첫보기엔 문제가 어려워보이기도하고 문자열문제라 처음봤을때 겁먹은 문제였다. 그래서 미루다미루다 결국 풀게됐는데, 생각보다 난이도가 낮았고 금방 풀 수 있는 문제였다. 문제만 보고 판단하지 않는게 좋겠다.
 
 
 
-----알고리즘-----
[핵심 아이디어]
I가 나오고 O가 나오면 카운트하는 알고리즘?
0, 1의 값을 가지는 temp같은 변수를 하나 설정한 뒤 temp == 0일 때 I가 오면 count가 1 늘어나고 temp = 1로 만들고
temp == 1일 때 O가 오면 다시 temp가 0이 되도록 한다? 만약 해당 값에 맞지않는 문자가 올 경우 count는 즉시 -1이 되고 temp == 0이 되는 식으로?
그리고 IOIOI에는 IOI가 2개 있듯 해당 문자안에는 count-n개의 P(n)이 있도록 한다?
정리하자면
문자열 input를 인덱스 0부터 탐색한다.
length_IOI의 기본값은 -1, turn은 0이다.
-I가 온 경우
1. 현재 turn값을 확인한다.
2. 만약 turn == 1인 경우 length_IOI == -1, turn = 0으로 만든다.
3. turn = 1로 한 뒤 length_IOI++한다.
4. length_IOI >= n인 경우 answer++한다.
-O가 온 경우
1. 현재 turn값을 확인한다.
2. 만약 turn == 0인 경우 length_IOI == -1
3. turn = 0으로 한다.
 
[알고리즘 흐름]
1. n을 입력받는다.
2. m을 입력받는다.
3. input을 입력받는다. (input[1001000])
4. 0~m-1까지 순환한다.(i)
 4.1. input[i] == 'I'인 경우
  4.1.1. turn == 1인 경우 length_IOI = -1, turn = 0
  4.1.2. turn = 1, length_IOI++
  4.1.3. 만약 length_IOI >= n인 경우 answer++한다.
 4.2. input[i] == 'O'인 경우
  4.2.1. turn == 0인 경우 length_IOI = 0
  4.2.2. turn = 1
5. answer을 출력한다.