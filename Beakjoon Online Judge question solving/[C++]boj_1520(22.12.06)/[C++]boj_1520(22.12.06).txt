문제 : 내리막 길 (1520번, 난이도 골드3)
풀이시간 : 32m

[문제 풀이]
<알고리즘 순서>
1. M, N을 입력받는다.
2. 2중 반복문을 통해 M*N번 반복하면서 map[1~M][1~N]값을 입력받는다.
3. searchRoute(M, N)을 출력한다.

<함수 설계>
-int searchRoute(int row, int column)-
1. row == 1 && column == 1인 경우 1을 리턴한다.
2. dp[row][column]==0인 경우만 다음을 실행하며 그렇지 않은 경우 7로 넘어간다.
3. 임의의 경우의 수를 담을 temp변수를 선언한다.
4. map[row][column] < map[row-1][column]인 경우 temp += searchRoute(row-1(+1), column)
5. map[row][column] < map[row][column-1]인 경우 temp += searchRoute(row, column-1(+1))
6. dp[row][column] = temp;
7. return dp[row][column];

[아이디어]
BFS 방식으로 경우의 수를 찾되 메모이제이션을 적용하여 특정 구역에서 경우의 수를 저장한 뒤
같은 연산을 되풀이 하지 않도록 하면 좋을 것 같다.

도착지점인 오른쪽 하단 즉, 문제에서 주어지는 (M, N)에서 부터 탐색을 시작하면 될 것이다.
경로를 탐색하는 것을 searchRoute(int row, int column)함수로 처리한다고 가정하자.
임의의 좌표 (R, C)에 대하여
searchRoute(R, C) = searchRoute(R-1, C) + searchRoute(R, C-1)로 탐색한다.
이 때 나오는 값을 dp[R][C]에 저장한 뒤 나중에 다시 searchRoute(R, C)가 호출될 경우 바로 dp[R][C]를
리턴하게 한다.
만약 searchRoute(1, 1)인 경우 1을 리턴한다.

이 문제에서는 도착지점까지 가는 경로의 수열이 내림차순이어야 하기 때문에
searchRoute(R, C) = searchRoute(R-1, C) + searchRoute(R, C-1)에서
map[R][C] < map[R-1][C] / map[R][C] < map[R][C-1]일 경우 searchRoute(R(R-1), C(C-1))를 더하도록 하자

왜 오른쪽, 아래로 갈 생각은 못했을까 추가하도록 하자.