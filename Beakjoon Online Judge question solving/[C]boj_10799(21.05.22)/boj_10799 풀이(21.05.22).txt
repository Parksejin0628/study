문제 : 10799번 '쇠막대기'(난이도 실버3)
풀이시간 : 13분 18초
한줄평 : 격리도 풀렸겠다 다시 시작하는 백준 문제 풀이이다. 자료구조 책을 산김에 자료구조 책을 학습하면서 관련된 문제를 풀려고 한다. 가볍게 스택으로 시작하는데, 생각보다 쉬운 문제여서 금방 풀 수 있었다.
 
----알고리즘----
[알고리즘 흐름]
1.문자열을 입력받는다.
2.문자열을 0~'\n'까지 훑는다.(또는 '(', ')'가 아닐 때 까지)
3.만약 문자가 '('인 경우 count++하고 stack ++ 한다.
4.만약 문자가 ')'인 경우 두 가지에 따라 나뉜다.
 4.1. 바로 직전의 문자가 '('인 경우 count--, count+=stack
 4.2. 바로 직전의 문자가 '('가 아닌 경우 stack--
 
-----------------------------------------------------------
문제 : 1406번 '에디터'(난이도 실버3)
풀이시간 : 38분 42초
한줄평 : 알고리즘 자체는 바로 떠올랐다. 그런데 여전히 문자열을 다루는데 익숙하지 않은 것이 느껴진다. 문자열을 다루는데 시간을 다써서 생각보다 오래 걸리고 말았다.
 
----알고리즘----
[핵심 아이디어]
 - 커서 왼쪽과 오른쪽에 있는 문자들을 따로 스택형태로 저장하자.
 - 커서가 왼쪽으로 움직일때마다 스택의 top문자를 오른쪽 스택으로 옮긴다.
 - 커서가 오른쪽으로 움직일때마다 오른쪽 스택의 top문자를 왼쪽으로 옮긴다.
 - P명령어는 그냥 왼쪽에 추가하면된다
 
[알고리즘 흐름]
1.stack_left를 입력받는다. (stack_left[600100]) 그 후 leftTop = strlen-1를 한다.
2.그 후 명령의 갯수 M을 입력받는다.
3.M번동안 반복하며 명령을 입력받는다.
 3.1. 명령어가 L인 경우 stack_right[++rightTop] = stack_left[leftTop--] 단, leftTop == -1인 경우 무시한다.
 3.2. 명령어가 D인 경우 stack_left[++leftTop] = stack_right[rightTop--] 단, leftTop == -1인 경우 무시한다.
 3.3. 명령어가 B인 경우 leftTop--; 단, leftTop == -1인 경우 무시한다.
 3.4. 명령어가 P인 경우 temp를 입력받고 stack_left[++leftTop] = temp
4.stack_left[0~leftTop]까지, stack_right[rightTop~0]까지 출력한다. 단, leftTop이나 rightTop == -1인 경우 해당 스택은 무시한다.