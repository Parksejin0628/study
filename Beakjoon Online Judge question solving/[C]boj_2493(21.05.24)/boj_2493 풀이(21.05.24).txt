문제 : 2493번 '탑' (난이도 골드 5)
풀이시간 : 29분 5초
한줄평 : 현재 스택을 공부하고 있어서인지 풀이알고리즘이 꽤 빨리떠올라서 골드문제 치고는 매우 빨리 풀 수 있었다. 약간 실력이 상승한 느낌이어서 기분이 좋기도 하지만, 문제가 쉬운 느낌도 없지않아 있다.
 
--------알고리즘----------
[핵심 아이디어]
high[100000000]를 저장해둔뒤 탑의 높이보다 낮은 인덱스들을 해당 탑의 번호로 바꾼 뒤 나중에 그 높이 인덱스에 있는 탑의 번호를 출력?
 - 높이가 100000000이면 연산만 1억번, 총 50만까지 있으니 50억번의 연산을 하게된다
 
탑의 높이를 스택으로 쌓아두고 탐색? 이걸로 가보자
 - 그러면 연산수가 NlogN
 
탑의 높이가 주어질 때 마다 현재쌓인 스택에서 자신보다 높이가 낮은 것들을 삭제, 그리고 즉시 수신하는 탑을 계산한다 가즈아.. 라고해도
 최악의 수는 똑같은데.. NlogN 아니지 높이가 가장 높은거는 무조건 0인것을 이용하면 연산수가 더 낮지
[알고리즘 흐름]
1.n을 입력받는다.
2.n번 반복하며 다음 과정을 수행한다.
 2.1. temp에 탑의 높이를 저장한다. (top = 0, stack[600000]
 2.2. stack[top~0][0]을 살펴보며 temp가 stack[index][0]보다 높으면 top--를한다.
 2.3. 만약 temp보다 높은 stack[index][0]을 발견하면 탐색을 중단하고 stack[index][1]를 출력, stack[++top][0] = temp, stack[top][1] = i를 한다. 
 2.4. 만약 top == -1이 된다면 0을 출력하고  stack[++top][0] = temp, stack[top][1] = i를 한다. 
 
 
[함수 세부내용]