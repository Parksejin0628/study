문제 : 10986번 "나머지 합" (난이도 골드 3)
풀이시간 : 50m

[풀이법]
1. N, M을 입력받는다.
2. N개의 수를 입력받는다.
3. 수를 입력받으면서 sum[i] = sum[i-1] + num;을 통해 누적합을 구한다.
4. 누적합을 구하면 remainder[sum[i]%M] ++ 를 시킨다.
5. 수를 모두 입력받은 뒤 모든 누적합을 순환하며 answer += remainder[i] * (remainder[i]-1) / 2;를 한다.
 5.1. 주의할 점은 입력값은 1,000,000,000으로 sum을 long long 으로, 최대 경우의 수가 50억정도이므로 answer, remainder도 long long으로 한다.
6. answer을 출력한다.

[메모]
최대로 들어오는 수의 개수 : 1,000,000
누적합을 구한 뒤 모든 구간합을 구하는 경우 : 약 1,000,001 * 500,000 = 5,000,000,500,000 50억이 넘는다?
그냥 구하면 시간 제한을 넘길거같다.

모듈러 법칙에 의하여
(A-B)%N = (A%N) - (B%N) % N 이 성립한다.
우리가 구하고자 하는 것은 (A-B) % N = 0인 경우이기 때문에 (A%N) - (B%N) % N = 0을 찾으면 된다.
(A%N) - (B%N) % N = 0이라는 사실은
A%N = B%N 이라는 사실과 같다고 볼 수 있지 않을까?
따라서, 누적합 A, B가 있다고 가정했을 때 A%N = B%N이면 자연스럽게 (A-B)%N = 0 이라는 사실을 유추해낼 수 있다.
여기서 나머지가 되는 N은 1,000 이하이기 때문에 충분히 누적합의 %N값을 저장해놓을 수 있다.
나머지가 같은 것끼리 묶어둔 뒤 조합을 구하면 쉽게 구할 수 있다.
조합을 구하는 공식은
nCk가 있을 때 nCk = n! / k!(n-k)! 이다.
그런데, k는 무조건 2로 고정이므로
nC2 = n! / 2!(n-2)! = n*(n-1) / 2 이정도면 연산의 수도 크지 않다.

정리하자면
1. 값을 받으면서 모든 누적합을 구해놓는다.
2. 누적합을 구할 때 M으로 나눴을 때의 나머지도 정리해놓는다.
3. 각 정리 구간마다 n(n-1) / 2를 통해 정답을 구한다.
4. 단, 처음부터 나머지가 0인 숫자들은 스스로도 정답이 되므로 그 개수만큼 한번 더 더한다.