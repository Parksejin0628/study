문제 : 7662번 (난이도 골드 4)
풀이시간 : 2h 22m

풀이법
 - 일단, 이중 우선순위 큐는 같은 데이터를 최대 힙(Max Heap)과 최소 힙(Min Heap)을 통해 정렬한 후 한 곳에서 값을 삭제하면
다른 쪽도 연계해서 삭제하는 방식이다.
문제는, 단순히 값을 삭제하면 힙을 다시 정렬하는 과정이 복잡해지기에 일단은 삭제하지 않고 '삭제예정'으로 둔 다음
해당 값을 출력하려 할 때 '삭제예정'인 값이면 삭제하고 다음 우선순위 값을 찾아내는 방식으로 진행할 것이다.\

- 우선순위 큐 : 오랜만에 사용하는 힙구조라 그런지 헷갈리는 경향이 있다. 한 번 생각을 정리하면서 어떻게 구현할지 생각해보자
힙 구조는 내가 알기로는 트리구조를 사용한다. 상위 계층을 부모, 하위 계층을 자식이라고 생각해보자.
일단, 최대힙 기준으로 정리해보면 모든 구역에서 부모 > 자식 기준이면 최대 힙이 완성되는 것으로 알고 있다.
   10		이런 구조가 있다고 가정해보자. 5의 자식인 4가 2보다 크지만 어느 구역을 보든 자식이 부모보다 작기에
 5    2		이 구조에는 문제가 없다. 만약 하나를 뽑아내더라도 5와 2중에 큰 5가 제일 우선순위가 될 것이고 4가 올라갈 것이다.
4 3 1  1		그러면 5를 뽑아내도 4와 2중 큰 4가 올라가기 때문에 부모>자식 이 관계만 유지되면 문제가 없어 보인다.
그러면, 이 힙 구조를 어떻게 구현하는가를 생각해보자.
      15		이런 구조까지 데이터가 정렬됐다고 생각해보자. 새로운 숫자 5를 추가한다.
  10     12	일단, 가장 상위인 10과 비교한다. 우선순위가 낮으니 그 자식들인 9, 8과 비교한다. 근데 이런 과정은 결국
7  4		비교해야 하는 숫자가 너무 많다. 따라서, 일단 가장 하위인 (마지막 인덱스) 8 밑으로 내려본다
      15		문제가 없네? 그러면 8 밑에 5를 추가한 형태로 만든다. 다음은, 같은 방식으로 13을 추가해본다.
  10     13	부모인 12와 비교했을 때 더 크니까 부모와 위치를 바꾼다. 그 다음 부모인 15보다는 작으니 기존 12위치에
7  6   5    12	위치시킨다. 그러면 어느 구조를 보아도 부모>자식인 형태가 완성이 된다.
      12		그 다음은 우선순위가 높은 15를 제거한다고 생각해보자. 일단, 가장 마지막값인 12를 맨 처음 값으로 올린다.
  10     13	그 뒤 자식과 비교하여 내려간다. 10보다는 12가 크니까 위치를 바꾸지 않고, 12보다는 13이 크니까 위치를 바꾼다.
7   6  5    	그 뒤 다시 자식과 비교해야 하는데 5보다 크니까 기존 13위치에 12가 존재하게 된다. 
      13		결국 부모>자식 형태는 여전히 완성이 된다.
  10     12	이러한 비교 형태를 수행하면 된다. 자신의 자식 위치는 (자신*2), (자신*2 + 1) 인 것을 이용한다.
7    6 5    	put : rearIndex에 값을 넣은 뒤 자신의 인덱스를 index라고 하면 index/2와의 값비교 후 위치를 바꾸는 과정을 반복한다.
get : rearIndex에 있는 값을 0번 위치로 옮긴 후 rearIndex -1, 그 후 자신의 인덱스를 index라고 하면 index와 index*2, index*2+1
와 값을 비교하여 자신이 더 작은 경우 위치교환 반복

[객체목록]
<Data>
한줄 설명 : 입력받는 값을 저장
멤버 변수 : int num / bool delete
멤버 함수
 - 생성자(void) : 처음 배열 생성용
 // - 생성자(Data copy) : 데이터 추가용
 // - 대입 연산자(Data copy) : 데이터 추가용
 - 대입 연산자(int inputNum) : 데이터 추가용
 - bool deleteData() : 데이터 제거용
 - int getNum() : num 가져오기

<DoublePriorityQueue>
한줄 설명 : 데이터를 이중 우선순위 큐를 통해 최댓값, 최솟값 정렬
멤버 변수 : Data* newData / Data* maxQueue[1000100] / Data* minQueue[1000100] / Data* temp_swap;
	  / int rearIndex_maxQueue / int rearIndex_minQueue / int parentIndex / int childIndex
멤버 함수
 - 생성자(void) : 초기화 및 배열 생성
 - void inputNewData(int input) : 새로운 데이터를 추가한 뒤 maxQueue, minQueue 재정렬
 - int maxPop(bool del) : maxQueue에서 우선순위가 제일 높은 데이터 제거
 - int minPop(bool del) : minQueue에서 우선순위가 제일 높은 데이터 제거
 - bool printAnswer() : 정답인 최댓값과 최솟값 혹은 EMPTY 출력


[Data의 멤버함수 정의]
<생성자(void)>
 - num = 0, delete = false로 초기화

// <생성자(Data copy)>
// - num = copy.num, delete = copy.delete

<대입 연산자(int inputNum)>
 - num = inputNum;

<bool deleteData(bool del)>
 - delete == false인 경우 delete true, return false;
 - delete == true인 경우 return true;
 - del = false인 경우 delete == false일 때 delete를 건들지 않는다.

<int getNum()>
 - return num


[DoublePriorityQueue의 멤버함수 정의]
<생성자(void)>
 - rearIndex_maxQueue = 1;
 - rearIndex_minQueue = 1;

<void inputNewData(int input)>
 - newData = new Data(input)
 - maxQueue[rearIndex_maxQueue++] = newData, maxQueue 정렬
 - minQueue[rearIndex_minQueue++] = newData, minQueue 정렬
 - 정렬 방법은 childIndex = rearIndex, parentIndex = childIndex / 2; 를 한 뒤 두 인덱스 값을 비교 및 교환한다.
   교환할 경우 childIndex = parentIndex, parentIndex = childIndex / 2; 로 바꾸며 반복한다.
   단, parentIndex < 1인 경우 중단한다.

<int maxPop(bool del)>
 - Data* popData = maxQueue[1], int retNum = *maxQueue[1].getNum();
 - maxQueue[1] = maxQueue[rearIndex_maxQueue--]
 - parentIndex = 1, childIndex = parentIndex * 2를 한 뒤 parentIndex, childIndex 값을 비교한다.
   만약 childIndex가 더 작은 경우 childIndex + 1을 한 뒤 다시 비교한다.
   비교하여 교환해야 하는 경우 parentIndex = childIndex, childIndex = parentIndex * 2를 하며 비교를 반복한다.
   단, childIndex >= rearIndex_maxQueue인 경우 중단한다.
 - *popData.deleteData(del)가 true인 경우 delete popData를 한 뒤 위 과정을 반복한다.
 - retNum을 리턴한다.

<int minPop(bool del)>
 - maxPop()를 최소값으로 한다.

<void printAnswer()>
 - maxPop(false), minPop(false)값을 받아 답을 출력한다.
데이터가 하나다 (rearIndex_maxQueue가 2이다.) 상관 x (물론 deleteData검증 후)
데이터가 없다. (rearIndex_maxQueue가 1이다.) EMPTY를 출력해야 한다.


