문제 : 11066번 "파일 합치기" (난이도 골드 3)
풀이시간 : 2h 20m (풀이중

[아이디어]
합친 뒤 파일의 크기 = 합치기 전 파일1의 크기 + 합치기 전 파일2의 크기 이다.

최종 최소비용 = 최종-1까지의 최소비용 + 최종-1까지의 최소비용이다.

40, 30, 30, 50의 비용이 있다고 가정하면
최소비용 : (30 + 40) + (30 + 50) + ((30 + 40) + (30 + 50)) = 300 이다.
경우의 수로는
(40 + 30) + ((40 + 30) + 30) + (((40 + 30) + 30)) + 50))) = 320.. 등이 있다.

아마 낮은 단계일 수록 최대한 작은 수가 들어가게 하면 최소가 나올거같은 기분이 든다.
한번 예제를 통해서 맞는지 확인해보자
1, 21, 3, 4, 5, 35, 5, 4, 3, 5, 98, 21, 14, 17, 32이 있다고 가정하자

(1) (1+5) (3+4) (3+5) (4+5) (21+21) (35+14) (17+32) = 6+7+8+9+42+49+49 = 170
(2) (6+7) (8+9) (49+42) = 15+17+91 = 123
(3) (15+17) (91+49) = 32 + 140 = 172
(4) (32+98) = 130
(5) (130 + 140) = 270

합 : 170 + 123 + 172 + 130 + 270 = 865

얼추 비슷한 느낌이다 남은 숫자중에서 최대한 숫자가 작은 것 끼리 짝을 지어서 합을 지으면
최소값이 나올 것 같다. 짝을 지은 것들은 다시 저장하여 이 과정을 반복하다보면 최소 비용이 나올 것이다.
위 예제에서 (2)과정에 남은 숫자가 8개인데 숫자를 6개만 쓴 것이 최소값이 안나온 이유인것 같다. 다시 해보자

()는 사용된 숫자를 의미한다.
(1)
남은 숫자 : (1) (21) (3) (4) (5) (35) (5) (4) (3) (5) 98 (21) (14) (17) (32) 
 - (1+3) (3+4) (4+5) (5+5) (14+17) (21+21) (32+35) = 4+7+9+10+31+42+67 = 170
(2)
남은 숫자 : (4) (7) (9) (10) (31) (42) (67) (98)
 - (4+7) (9+10) (31+42) (67+98) = 11+19+73+165 = 268
(3)
남은 숫자 : (11) (19) (73) (165) 
 - (11+19) (73+165) = 30+238 = 268
(4)
남은 숫자 : (30) (238)
 - 30 + 238 = 268

최종 : 170 + 268 + 268 + 268 = 974
음.. 뭐가 문제일까
98이라는 숫자의 영향이 3번이나 들어간 것이 큰 것 같다.
저번 시도에서는 2번밖에 안들어가서 작은 수가 나온 것이 아닌가 싶다.

2번째 시도로 남은 숫자중 제일 작은 수 2개만 합치는 것이다.
그리고 합친 수를 남은 수에 추가시키고 이 과정을 반복하면 되지 않을까 대신 과정이 좀 길 것이다.
일단, 이 시도를 통해 예제를 해보자 매 순간마다 정렬을 해보자


(1)
남은 숫자 : 1 3 3 4 4 5 5 5 14 17 21 21 32 35 98 
1+3 = 4

(2)
남은 숫자 : 3 4 4 4 5 5 5 14 17 21 21 32 35 98
3+4 = 7

(3)
남은 숫자 : 4 4 5 5 5 7 14 17 21 21 32 35 98
남은 숫자 : 4 4 5 5 5 7 14 17 21 21 32 35 98
4+4 = 8

(4)
남은 숫자 : 5 5 5 7 8 14 17 21 21 32 35 98
남은 숫자 : 5 5 5 7 8 14 17 21 21 32 35 98
5+5 = 10

(5)
남은 숫자 : 5 7 8 10 14 17 21 21 32 35 98
남은 숫자 : 5 7 8 10 14 17 21 21 32 35 98
5+7 = 12

(6)
남은 숫자 : 8 10 12 14 17 21 21 32 35 98
남은 숫자 : 8 10 12 14 17 21 21 32 35 98
8+10 = 18

(7)
남은 숫자 : 12 14 17 18 21 21 32 35 98
남은 숫자 : 12 14 17 18 21 21 32 35 98
12+14 = 26

(8)
남은 숫자 : 17 18 21 21 26 32 35 98
남은 숫자 : 17 18 21 21 26 32 35 98
17+18 = 35

(9)
남은 숫자 : 21 21 26 32 35 35 98
남은 숫자 : 21 21 26 32 35 35 98
21+21 = 42

(10)
남은 숫자 : 26 32 35 35 42 98
남은 숫자 : 26 32 35 35 42 98
26+32 = 58

(11)
남은 숫자 : 35 35 42 58 98
남은 숫자 : 35 35 42 58 98
35+35 = 70

(12)
남은 숫자 : 42 58 70 98
남은 숫자 : 42 58 70 98
42+58 = 100

(13)
남은 숫자 : 70 98 100
남은 숫자 : 70 98 100
70+98 = 168

(14)
남은 숫자 : 100 168
100+168 = 268
합 : 4+7+8+10+12+18+26+35+42+58+70+100+168+268 = 826?

왜 이렇게 나오는 걸까

한가지 문제에서 놓치고 있던 부분이 있다.

파일이 연속적으로 되도록 하는 것
즉, 맨 왼쪽 파일과 오른쪽 파일을 합치거나 할 수 없는 것이다.
양옆에 인접한 파일만 합칠 수 있는 것이다.

그러면, 간단하다
양옆에 인접한 파일을 합쳤을 때 합이 가장 작은 파일을 골라 합친다.
이제야 좀 동적계획법 느낌이 난다.

(1)
남은 숫자 : 1 21 3 4 5 35 5 4 3 5 98 21 14 17 32
합이 가장 작은 조합 : 3+4 = 7

(2)
남은 숫자 : 1 21 7 5 35 5 4 3 5 98 21 14 17 32
합이 가장 작은 조합 : 3+4 = 7

(3)
남은 숫자 : 1 21 7 5 35 5 7 5 98 21 14 17 32
합이 가장 작은 조합 : 7+5 = 12

(4)
남은 숫자 : 1 21 12 35 5 7 5 98 21 14 17 32
합이 가장 작은 조합 : 7+5 = 12

(5)
남은 숫자 : 1 21 12 35 12 5 98 21 14 17 32
합이 가장 작은 조합 : 12+5 = 17

(6)
남은 숫자 : 1 21 12 35 17 98 21 14 17 32
합이 가장 작은 조합 : 1+21 = 22

(7)
남은 숫자 : 22 12 35 17 98 21 14 17 32
합이 가장 작은 조합 : 14+17 = 31

(8)
남은 숫자 : 22 12 35 17 98 21 31 32
합이 가장 작은 조합 : 22+12 = 34

(9)
남은 숫자 : 34 35 17 98 21 31 32
합이 가장 작은 조합 : 21+31 = 52

(10)
남은 숫자 : 34 35 17 98 52 32
합이 가장 작은 조합 : 35+17 = 52

(11)
남은 숫자 : 34 52 98 52 32
합이 가장 작은 조합 : 52+32 = 84

(12)
남은 숫자 : 34 52 98 84
합이 가장 작은 조합 : 34+52 = 86

(13)
남은 숫자 : 86 98 84
합이 가장 작은 조합 : 84+98 = 182

(14)
남은 숫자 : 86 182
합이 가장 작은 조합 : 86+178 = 268

합 : 7+7+12+12+17+22+31+34+52+52+84+86+182+268 = 866 ?

정석 풀이와 비교를 해보니

5 4 3 5 부분에서
(((4+3) + 5) + 5)가 아닌
(5+4) + (3+5)를 했다.
인접한 크기가 작은 것들을 선정하는 것은 무조건 옳지 않은 것 같다.
그러면 어떤 케이스를 선택해야하는 걸까
뭔가 누적합을 통해 동적계획법을 설계해야 할 것 같다.
일단, 감은 어느정도 오지만, 확실하지 않으니 기본적인 정보를 정리해보자

숫자의 개수가 k개인 경우 k-1번의 연산이 필요하다.
즉, 연산을 바탕으로 동적계획법을 짜면 그럴듯 할 것이다.

숫자의 개수가 15개인 경우 우리는 연산을 14번 했을 때의 최소값을 구하면 된다.
그리고 연산 14번은 연산을 n번 한것 + m번 한것 (단, n+m = 13)로 구성되어있다.
연산을 n번 한 것은 연산을 i번 한것 + j번 한것 (단, i+j = n-1)으로 구성되어있다.

즉, 최소비용은
연산을 i번 한것 + j번 한 것(단, i+j = n-1)중 가장 최소값을 구하면 되는 것이다.
그런데, 연산을 i번 한 것, j번 한 것의 특징이 있다.
연산을 i번 한 것은 좌측의 숫자 i+1개를 사용하고, j번은 나머지 우측의 숫자 j+1개를 사용한다.

아직까지 감이 안온다.
동적계획법 기반 사고를 해보자
여태까지 합한 비용을 sum이라 해보자.
그리고, 현재 연산단계를 알기위해 배열을 추가하자.
즉, sum[k-1]의 최소값을 구하는게 우리의 목표이다.
수많은 sum[n]중 최소값을 min[n]이라고 하면
min[n] = min[i] + min[j] (단, i+j = n-1)이 된다.
즉, min[n]을 찾기 위해서는
min[0] + min[n-1]
min[1] + min[n-2]
...
min[i] + min[n-i-1]
(단, n-i-1 > i)
이 중 가장 작은 값을 찾으면 된다.

작은 값부터 접근해보자
첫번째 예제 40 30 30 50 을 예로 들면
min[3]을 찾아야 한다.
min[3]의 후보로는
min[0] + min[2]
min[1] + min[1] 이 있다.

min[0]은 파악하기 쉽다.
모든 기본 데이터 중 가장 작은 값을 고르면 된다.
즉, 30이다.
min[1]은 1번 연산한 값 중 가장 작은 값을 고르면 된다.
즉 수많은 sum[1]중 가장 작은 값을 찾으면 된다.
sum[1]은 다음과 같다.
{70, 60, 80}
즉, min[1]은 60이다.

일단, 문제점이 보이지만 마무리한 뒤 다시 탐구한다.

min[2]는 min[0] + min[1]이다.
즉, 60+30 = 90이다.
그런데, 문제는 min[1]에서 기본데이터인 30을 모두 사용하고, min[0]또한 30이어서 30이 부족하다는 점이다.
숫자를 중복해서 사용하면 안되는데 이를 어떻게 처리해야하나

문득 떠오르는 생각중 하나는 다음과 같다.
아까 숫자를 분리하는 아이디어를 통해서
min[n][m]에서 n, m을 n번째 숫자 ~ m번째 숫자를 사용했을 때 최소값으로 생각하는 것이다.
우리가 구하고자 하는 것은 min[0][k-1]이 된다.
k를 max라고 하자
min[0][max] = min[0][i] + min[i+1][max]이 된다.
min[0][max]의 후보는
min[0][0] + min[1][max]
min[0][1] + min[2][max]
...
min[0][i] + min[i+1][max]가 된다.

아까처럼 첫번째 예시를 통해 시뮬레이션을 해보자
40 30 30 50에서 우리가 구해야하는 값은 min[0][3]이다.
min[0][3]의 후보는
min[0][0] + min[1][3]
min[0][1] + min[2][3]
min[0][2] + min[3][3]
이 있다.
min[0][0]은 당연히 40
min[3][3]도 당연히 50이다.
min[0][1]은 70
min[2][3]은 80이다.
문제는 min[0][2], min[1][3]인데
같은 방식으로 min을 구하다 보면 나올 것이다.
min[0][2]의 후보는
min[0][0] + min[1][2]
min[0][1] + min[2][2]
각각의 값은
40 + 60
70 + 30
즉, 100이다.
즉, min[0][2] = 100이다.
min[1][3]의 경우는
min[1][1] + min[2][3]
min[1][2] + min[3][3]이 후보고
각각의 값은
30 + 80
60 + 50
즉, 110이다.
결국 min[0][3]의 후보로는
40 + 110

... 오류가있다.
누적합을 생각을 안한 것이다.
n~m번 숫자까지의 누적합 최소값은
n~i번 숫자까지의 누적합중 최소값 + (i+1) ~ m번 숫자까지의 누적합중 최소값 + n~i번 숫자들의 합 + (i+1) ~ m번 숫자까지의 합
이 되는 것이다.

이제는 n~m의 누적합중 가장 작은 값을을 sum[n][m]으로 두고 구간에서 기본 값을 더한 값을 value[n][m]
minSum : 모든 경우의 누적합 중 가장 작은 값, minIndex : 누적합이 가장 작은 값이 나온 구간의 인덱스
minValue = 구간의 기본 숫자들을 더한 값 이라고 생각하자. 즉, 최종적으로 sum[n][m]에는 minSum이 들어간다.
다시 첫번째 예시로 돌아가서
40 30 30 50에서 sum[0][3]을 구하려면 후보는 다음과 같다.
1. sum[0][0] + sum[1][3] + value[0][0] + value[1][3]
2. sum[0][1] + sum[2][3] + value[0][1] + value[2][3]
3. sum[0][2] + sum[3][3] + value[0][2] + value[3][3]

후보 하나씩 정리해보자
1번 후보
sum[0][0]은 0이다. 누적합이 없기 때문이다.
sum[1][3]은 추후에 계산한다.
value[0][0]은 40
value[1][3]은 30 + 30 + 50 = 110이다.

sum[1][3]또한, 동적계획법방식으로 계산한다.
후보는
1.sum[1][1] + sum[2][3] + value[1][1] + value[2][3]
2.sum[1][2] + sum[3][3] + value[1][2] + value[3][3]










