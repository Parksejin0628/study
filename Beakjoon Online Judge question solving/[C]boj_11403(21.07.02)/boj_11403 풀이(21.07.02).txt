문제 : 11403번 '경로 찾기' (난이도 실버1)
풀이시간 : 1시간 11분 35초
한줄평 : 생각보다 두뇌가 안돌아가서 풀이 생각하는데 꽤 오래걸렸다. 하루 텀을 두고 문제를 푼 것도 헷갈리는데 큰 비중을 차지했다. 하지만, 알고리즘 고민이 오래걸린만큼 코딩시간은 매우 짧아서 10분안에 코딩이 끝난 듯 하다.
 
 
 
----알고리즘----
[핵심 아이디어]
BFS로 푸는 것이 가장 간단해보인다.
입력받을 때 간선을 배열로 저장하고, BFS를 통해 탐색해서 찾고자 하는 위치를 찾으면 될듯하다.
BFS를 통해 탐색할 때 check변수는 시작점만 체크한다.
r -> c를 탐색한다 치면 행렬 (r,c)를 1로 한 뒤 (n, r) = 1인 좌표를 탐색하여 (n, c)또한 1로한다. 이 과정은 (n, c)에서 또한 실행한다.
 
정리
1. 먼저 간선을 입력받는다.
2. 정점 (1,1)부터 순회하며 간선이 존재하며, check변수가 0인 정점을 찾는다.
3. 해당 정점부터 BFS로 탐색을 시작한다. 탐색을 시작한 정점은 check변수를 1로 바꾼다.
4. 탐색하는 정점을 r, 간선이 가리키는 정점을 c라고 하면 정답행렬 (r,c) = 1로 바꾼다.
5. (n, r) == 1인 정점을 찾아 (n, c) = 1로 바꾸는 함수를 호출한다. 이 함수 안에서 찾는 (n, c)또한 이 함수를 재귀호출한다.
 
[알고리즘 흐름]
1. n을 입력받는다.
2. n번만큼 반복한다. (r)
 2.1. n번만큼 반복한다. (c)
  2.1.1. temp를 입력받는다.
  2.1.1. 만약 temp == 1인 경우 edge[r][++edgeTop[r]] = c (edgeTop의 기본값은 0)
3. n번만큼 반복한다. (r)
  3.1.1. edgeTop[r] > 0인 경우 searchVertex(r, n)를 실행한다.
4. n번만큼 반복한다. (r)
 4.1. n번만큼 반복한다. (c)
  4.1.1. answer[r][c]를 출력한다.
 4.2. 개행문자를 출력한다.
 
[함수 세부내용]
-void searchVertex(int r, int n)-
1. searchStack[now][++stackTop[now]] = r
2. stackTop[now] != -1인 동안 반복
 2.1. stackTop[now] != -1인 동안 반복
  2.1.1. R = searchStack[now][stackTop[now]--];
  2.1.2. 1~edgeTop[R]까지 반복한다. (i)
   2.1.2.1. C = edge[R][i];
   2.1.2.2. answer[r][C] = 1;
   2.1.2.3. 만약 checkVertex[C] == 1인 경우
    2.1.2.3.1. 1~n까지 반복한다.(j)
    2.1.2.3.2. 만약 answer[C][j] = 1인 경우 answer[r][j] = 1, checkBFS[j] = 1;
   2.1.2.4. else checkBFS[C] != 1인 경우 searchTop[next][++stackTop[next]] = C;
   2.1.2.5. checkBFS[C] = 1
 2.2. next, now 교대