문제 : 양팔저울 (2629번, 골드 3)
풀이 시간 : 1h 17m

[문제풀이]
<알고리즘 흐름>
1. numberOfWeight를 입력받는다.
2. weight[0 ~ numberOfWeight-1]를 입력받는다.
3. numberOfBead를 입력받는다.
4. numberOfBead만큼 반복하며 5~7을 반복한다.
5. beadWeight를 입력받는다.
6. answer = scale(0, beadWeight) (answer는 bool)
7. answer = true 인 경우 Y 를, answer = false인 경우 N 을 출력한다.

<함수 설계>
- bool scale(int index, int requiredWeight) -
1. dp[index][requiredWeight] 값이 0이 아닌 경우는 7번부터 진행한다.
2. weight[index] == requiredWeight 인 경우 dp[index][requiredWeight] == 1
3. scale(index+1, requiredWeight + weight[i]) == true 인 경우 dp[index][requiredWeight] == 1
4. scale(index+1, requiredWeight - weight[i]) == true 인 경우 dp[index][requiredWeight] == 1
5. scale(index+1, requiredWeight) == true 인 경우 dp[index][requiredWeight] == 1
6. 2~5번에 해당하지 않는 경우 dp[index][requiredWeight] == -1
7. dp[index][requiredWeight] == -1인 경우 false, 1인 경우 true를 반환한다.

[아이디어]
'구슬 + 여러개의 추 = 여러개의 추' 가 가능한지 물어보는 문제이다.
이 문제가 동적 계획법 문제에 속해있지만, 일단 이를 고려하지 않고 어떻게 풀이해야 할지 고민해보자
가장 심플한 거는 모든 경우의 수를 다 넣어보는 것이다!

일단, 구슬쪽에는 추를 추가하지 않고 여러개의 추를 통해 구슬의 무게와 같게 하려면 어떻게 해야 할까

문제에 대한 감이 잡히지 않아 어느정도 검색을 해본 결과 i번째 무게 추에 대해
1. 왼쪽 저울에 놓는다.
2. 오른쪽 저울에 놓는다.
3. 아무것도 하지 않는다.

이 세가지의 경우의 수를 두고 문제를 해결하면 된다는 힌트를 얻을 수 있었다.

입력받은 저울을 배열에 저장한 뒤 차례대로 순회하면서 다음 경우가 가능한지 확인한다.

현재 살펴보는 저울의 인덱스 값을 index, 현재 요구되는 무게를 weight라고 할 때

1. scale(index+1, nowWeight + weight[i])
2. scale(index-1, nowWeight - weight[i])
3. scale(index-1, nowWeight)

그리고, 함수의 결과를 dp[index][nowWeight]에 bool형태로 저장해놓는다.
만약 1, 2, 3 모두 false로 돌아온다면 false로 반환하는 방식으로 한다.
언제든지 nowWeight == weight[i]인 경우 true를 반환한다.

정리하자면 다음과 같다.
1. 추의 갯수 및 무게를 입력받는다.
2. 구슬의 갯수 및 무게를 입력받는다.
3. 각 구슬마다 scale(0, 구슬의 무게)를 호출하고 true가 반환되면 Y를 false가 반환되면 N을 출력한다.