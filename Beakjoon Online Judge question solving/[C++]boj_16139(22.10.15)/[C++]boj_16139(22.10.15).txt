문제 : 16139번 (난이도 실버 1)
풀이시간 : 53m

[풀이법]
1. 문자열 S를 입력 받는다.
2. 문자열을 처음부터 끝까지 탐색하며 0~n(0~문자열 길이)에 특정 알파벳이 몇 개 있는지 파악한다. (2.1.)
3. 질문의 수 q를 입력 받는다. 이 다음 구간을 q번 반복한다.
4. 알파벳 a, 구간 l, r 를 입력 받는다.
5. count_alph[a][r] - count_alph[a][l-1]를 통해 특정 구간의 알파벳을 파악한 뒤 출력한다.

2.1. 0~strlen(S)까지 반복한다.
2.2. count_alph[S[i] - 'a'][i] = count_alph[S[i] - 'a'][i-1] + 1;
2.3. count_alph[나머지][i] = count_alph[나머지][i-1];

[메모]
200000자 이하의 문자열을 입력 받고, 특정 구간에 특정 알파벳이 몇 개 있는지 구하는 문제이다.

문자열 S를 입력받은 후 질문의 수 q를 입력받는다.
그 후 q만큼 반복하며 특정 알파벳, 구간을 입력받는다.
각 구간에 특정 알파벳이 몇 개 들어있는지 파악하면 된다.

만약, 질문이 들어올 때 마다 특정 알파벳을 세기 위해 브루트 포스 형식으로 탐색하면
200000 * 200000 = 40,000,000,000 약 400억으로 1초인 제한시간을 맞추기엔 턱없이 연산 횟수가 많다.

따라서, 생각한 것은 에초에 문자열을 받을 때 부터 모든 알파벳의 등장 횟수를 파악하는 것이다.
0~n까지 특정 알파벳 a가 몇개 들어가는지 미리 전부 세어둔 뒤 특정 구간을 물어볼 때 마다.(구간을 l~r이라 하자.)
(0~r) - (0~l-1)을 수행하면 단 한 번의 연산으로 파악할 수 있다.
미리 파악할 때에도 문자열을 입력 받을 때 한 번만 연산하면 되므로 시간 제한에도 문제가 없다.
메모리 공간의 경우 200000(문자열 길이) * 26(알파벳 개수) = 5,200,000byte로 제한인 256MB를 넘기지 않는다.