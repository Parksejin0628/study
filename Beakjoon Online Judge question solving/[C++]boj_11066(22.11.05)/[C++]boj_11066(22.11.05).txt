문제 : 파일 합치기 (11066번, 난이도 골드 3)
풀이시간 : 2h 22m

[풀이 중 메모]
누적 비용 = 전단계 누적 비용 + 현재 합치려는 값의 크기
이는 누적 비용의 최소 = (전단계 누적 비용 + 현재 합치려는 값의 크기)값의 최소를 의미한다.


인접한 두 수가 가장 작은 경우를 계속해서 고르면 가능하지 않을까 하는 가설이 생긴다.
예제 2번을 통해 확인해보자

1 21 3 4 5 35 5 4 3 5 98 21 14 17 32
 1 21 7 5 35 5 4 3 5 98 21 14 17 32			7
  1 21 7 5 35 5 7 5 98 21 14 17 32			14
   1 21 12 35 5 7 5 98 21 14 17 32			26
    1 21 12 35 12 5 98 21 14 17 32			38
     1 21 12 35 17 98 21 14 17 32			55
      22 12 35 17 98 21 14 17 32			77
       22 12 35 17 98 21 31 32			108
        34 35 17 98 21 31 32				142
          34 52 98 21 31 32				194
           34 52 98 52 32				246
            34 52 98 84				330
              86 98 84				416
               86 182					598
                 268					866

가설이 틀렸다..
2번 예제에 대한 정해는 다음이다.
1 21 3 4 5 35 5 4 3 5 98 21 14 17 32
 22 3 4 5 35 5 4 3 5 98 21 14 17 32			22
  22 7 5 35 5 4 3 5 98 21 14 17 32			29
   22 12 35 5 4 3 5 98 21 14 17 32			41
    34 35 5 4 3 5 98 21 14 17 32			75
     34 35 9 3 5 98 21 14 17 32			84
      34 35 9 8 98 21 14 17 32			92
       34 35 17 98 21 14 17 32			109
        34 52 98 21 14 17 32				161
         86 98 21 14 17 32				247
          86 98 21 31 32				278
           86 98 52 32				330
            86 98 84					414
              86 182					596
                268					864

이번 가설이 틀림으로써 확실히 깨달아야하는 것은 알고리즘 문제뿐만 아니라 앞으로 내가 해결할
모든 문제에는 명쾌한 공식이 없을 가능성이 높다는 것이다.
이번에도 무언가 공식이 있지 않을까 접근했고, 틀린 가설 근처만 빙빙 돌게 되었다고 생각한다.
공식을 찾는 태도가 아닌 논리적, 컴퓨터의 시선으로 접근해보자.



최소비용을 찾는 방법은 간단하다.
현재 단계 최소비용 = (전단계 + 전단계)중 최소비용 이다.
일단, 깡으로 모든 경우의 수를 구한다음 최소비용을 찾는다고 생각해보자.
이 방법을 찾으면 문제를 해결하는 방법을 향해 한발자국 더 가까이 갈 수 있으리라고 생각이 든다.

해당 배열의 모든 경우의 수를 계산하는 함수에서
각 계산한 후의 배열을 재귀함수를 통해 보내는 간단한 함수
구현해보자.

1. 배열, 배열의 길이를 입력받는다.
2. i = 0~배열길이-2로 순환한다.
3. num[0~i-1], num[i] + num[i+1], num[i+2~배열길이 -1]까지 저장한 배열을 만든 뒤 재귀함수를 호출한다.

문제풀이의 진전이 없어 자연스럽게 지치고 피하게 되었다.
앞으로 문제풀이가 너무 막힐 경우에는 해답을 찾고 공부하는 방향으로 가자.
너무 오랫동안 문제를 끌게 되면 문제풀이 자체에 대한 흥미가 떨어지고 피하게 된다.

문제풀이에 대한 접근을 살펴보았다.
수열이 n개 있다고 가정해보자
결국 마지막에 합쳐지는 파일은 (1~i번째까지 합친 파일) + (i+1~n까지 합친 파일) 일 것이다.
그러면 이 값이 최소값이 되려면 위 수식이 최소값이 되는 부분을 찾으면 된다.
그리고 이 법칙을 다이나믹 프로그래밍 방식으로 접근하여 아랫단계로 나아가면 된다.
예를 들어 1~i번째까지 합친 파일의 최소값을 찾으려면 (1~j) + (j~i)의 최소를 찾으면 될 것이고
이를 반복해서 내려가다보면 최소값을 발견할 것이다.

이에 대한 접근법을 기반으로 한번 더 생각해보자.
처음 살펴본 블로그에서는 i~j까지 합쳤을 때 최소 비용을 dp[i][j]로 정의했었다.
int sumFile(범위 왼쪽값(이하 left), 범위 오른쪽값(이하 right)) 함수를 선언한 뒤
반복문을 통해 sumFile(left, i) + sumFile(i+1, right)를 호출하면서 최소값을 찾으면 될 것이고
이미 dp[left][right]값이 있다면 이것을 반환하는 형태로 가면 될 것이다.
또한, 합칠 때 비용도 알아야하므로 sum[i][j]형태의 변수도 필요할 것이다.

1. mergeFile(left, right) (초기엔 0, n으로 호출)
2. 만약 dp[left][right] != 0 인 경우 dp[left][right] 리턴
3. 만약 left == right인 경우 num[left]를 리턴
4. left~right-1까지 반복문을 돌리면서 mergeFile(left, i) + mergeFile(i+1, right) + sum(left, right) (파일 합칠 때 비용)
5. 반복문을 돌리면서 최소값을 찾은 뒤 dp[left][right]에 최소값을 저장
6. return dp[left][right];