문제 : 동전 1 (2293, 골드 5)
풀이시간 : 2h 13m

[풀이법]
<알고리즘 흐름>
1. coinCount, value를 입력받는다.
2. coin[0~coinCount-1]을 입력받는다.
3. mergeSort(0, coinCount-1)를 통해 coin을 정렬한다.
4. searchCase(value)를 출력한다.

<함수 설계>
-void mergeSort(int start, int end)-
병합정렬을 통해 coin을 정렬시킨다.

-int searchCase(int value)-
0. value == 0인 경우 1를 리턴한다.
1. dp[value] == 0인 경우 2~3을 실행하며 아닌 경우 4로 넘어간다.
2. 0~coinCount-1,  1~value/coin[i] 이중 반복문을 하며 3번을 반복한다.
3. dp[value] += searchCase(value-coin[i]*j);
4. 만약 dp[value] == 0인 경우 dp[value] = -1
4. return dp[value]; 단, dp[value] == -1인 경우 0 리턴

[아이디어]
동전을 coin, 가치를 value라고 하면
처음에 coin[0]을 0개부터 value / coin[0]개 만큼 넣어보면서 넣은 뒤 다른 동전의 경우의 수를 파악한다.
즉, for(int i=0; i<value/coin[0]; i++)일 때
solution(coin[1], value - coin[0]*i)를 모두 더한 뒤 합을 구하는 것이다.
그리고, dp[coin[0]][value]에 값을 저장하여 메모이제이션을 한다.
즉, dp[동전의 가치][가격]이 되는 것이다.

w = 0인 경우 1을 리턴하고
만약, 마지막 동전까지 갔는데 가치가 남아있다면 0을 리턴한다.

여기서 궁금한 것은 동전을 정렬하고 하는 것이 빠르냐 아니냐는 것이다.
동전이 100개 이하이므로 정렬하는데 그렇게 많은 경우의 수를 차지하지 않고 k는 10000까지 있기에
정렬이 낫다고 생각한다.

즉, 순서는
1. 동전의 갯수와 목표 가치를 입력받는다.
2. 동전의 가치들을 입력받는다.
3. 동전을 가치순으로 정렬한다.
4. 다이나믹프로그래밍으로 순회한다.
가 되는 것이다.

메모리초과!
dp를 1차원 배열로 할 수 있는 방법을 모색해야 한다.
dp[가치]로 해놓고 searchCase는 (value)만 받도록 한 뒤 
coin[0~coinCount-1]를 차례대로 넣어보게 해야겠다.
dp[가치] = 가치 / coin[i]로 일단 한 뒤
dp[가치] = 가치 / coin[i] - j + searchCase(가치 - coin[i]*j)이런식으로 하면 찾아지지 않을까 예상이 된다.

이중 반복문을 해두고
dp[가치] += searchCase(value - coin[i]*j)로 하는 것이다.
기존 틀은 그대로 납두고 이를 기반으로 다시 설계해보자.

알아본 결과 수가 작은 동전부터 넣어보며
dp[가치] = dp[가치] + dp[가치 - 동전의 가치]를 하면 된다.