namespace Chapter07
{
    class mainApp
    {
        static void Main(string[] args)
        {


        }
    }
}

/*
[Chapter07 클래스]
<7.1. 객체지향 프로그래밍과 클래스>
1. 객체지향 프로그래밍
    1) 정의 : 코드 내의 모든 것을 객체로 표현하고자 하는 프로그래밍 패러다임
    2) 객체의 속성을 필드(Field), 기능을 메소드(Method)로 표현한다.
2. 클래스와 객체
    1) 클래스 : 객체를 만들기 위한 설계도같은 개념이다.
    2) 객체 : 클래스를 기반으로 만들어진 객체이다. 실체, 인스턴스(Instance)라고도 부른다.

<7.2. 클래스의 선언과 객체의 생성>
1. 클래스의 구성
    1) 멤버(Member) : 클래스 내에 선언된 요소들을 의미한다.
        - 필드(Field) : 클래스 안에 선언된 변수
        - 메소드(Method)
        - 이벤트(Event)
        - 프로퍼티
2. 객체 생성
    1) 생성자 : 객체를 생성하는 역할을 하는 메소드
        - 메소드의 이름이 클래스의 이름과 동일하다.
    2) 객체 생성 방법 : 클래스명 객체이름 = new 생성자
        ex) Cat kitty = new Cat();
        ex) Dog puppy = new Dog(2, "mandoo");
    3) 클래스는 복합 데이터 형식이다. 따라서, 객체명은 객체의 위치를 가리키는 참조형 변수이다.

<7.3. 객체의 삶과 죽음에 대하여>
1. 생성자
    1) 객체가 생성될 때 호출되는 메소드이다.
    2) 클래스와 이름이 같고 반환 형식이 없다.
        ex) class Test { ... public Text(int a) { ... } ... }
    3) 기본 생성자 : 생성자를 구현하지 않으면 컴파일러가 알아서 만들어주는 생성자.
        - 하지만, 객체 생성과 동시에 필드를 초기화 하고자 하면 생성자를 따로 구현하는 것이 좋다.
    4) 생성자도 오버로딩이 가능하다.
2. 종료자
    1) 가비지 컬렉터에 의해 객체가 소멸되는 시점에 호출되는 메소드이다.
    2) 클래스 이름 앞에 ~를 붙인 형태이며 한정자, 매개변수, 반환 형식이 모두 없다.
        ex) class Text { ... ~Text() { ... } ... }
    3) 여러 이유로 인해 가급적 사용하지 않는 것을 권한다.
        1] CLR의 가비지 컬렉터가 언제 동작할지 예측할 수 없다.
        2] 응용 프로그램의 성능 저하를 초래할 확률이 높다.
        3] 가비지 컬렉터로 객체의 소멸을 처리하는 것이 더 효율적이다.

<7.4. 정적 필드와 메소드>
1. 정적 필드
    1) 정적 필드 : 여러 개가 존재할 수 있는 인스턴스가 아닌 단 하나인 클래스에 소속되는 필드이다.
        - 필드 앞에 static 한정자를 붙여서 선언한다.
        - 단 하나뿐인 클래스에 소속되어 있으므로 그 프로그램에 단 하나뿐인 필드이다.
    2) 전역 변수처럼 사용하고 싶은 변수가 있다면 정적 필드를 이용하면 된다.
2. 정적 메소드
    1) 정적 메소드 : 클래스에 소속되는 메소드이다.
        - 정적 필드와 마찬가지로 static 한정자를 붙여서 선언하며 단 하나뿐이다.
    2) 인스턴스 메소드 : 정적 메소드가 아니라 인스턴스에 소속된 메소드이다.
        - 반드시 인스턴스가 생성되어야 사용할 수 있는 인스턴스이다.
    3) 정적 메소드의 활용 : 인스턴스의 필드를 이용하지 않는 메소드는 보통 정적 메소드로, 이용하는 경우 인스턴스 메소드로 사용한다.

<7.5. 객체 복사하기 : 얕은 복사와 깊은 복사>
1. 얕은 복사
    1) 단순히 인스턴스 변수를 선언한 후 이미 있는 인스턴스를 복사하면 같은 인스턴스를 가리키게 된다.
        - 인스턴스는 참조 형식을 사용하기 때문에 인스턴스 복사가 아닌 주소 값을 복사하는 것이기 때문이다.
    2) 얕은 복사 : 단순히 주소만 복사하는 경우를 의미한다.
2. 깊은 복사
    1) 인스턴스의 내용을 복사해서 받아 별도의 힙 공간에 보관하는 것이다.
    2) C#에서 기본적으로 제공하는 것이 없기에 새로운 공간을 할당해서 주소 값을 리턴하는 식으로 깊은 복사를 구현한다.

<7.6. this 키워드>
1. this
    1) this 키워드는 객체가 자신을 가리킬 때 사용하는 키워드이다.
        ex) this.value = 3;
    2) 다른 클래스의 멤버와 이름이 겹치는 경우 누군가를 가리키는지 알 수 없는 모호함을 해결할 때 많이 사용한다.
2. this() 생성자
    1) this()는 자기 자신의 생성자를 가리키는 메소드이다.
    2) this()는 생성자에서만 사용할 수 있으며 그 중에서도 생성자 선언부 뒤에 : this()로 선언한다.
        ex) public MyClass(int b, int c) : this(b) { ... }

<7.7. 접근 한정자로 공개 수준 결정하기>
1. 은닉성(Encapsulation)
    1) 클래스의 사용자에게 최소한의 기능만 노출하고 나머지는 숨기는 것이다.
    2) 객체지향 프로그래밍의 3대 특성 중 하나이다.
    3) 특히 필드는 상수를 제외하고 무조건 숨기는 것이 좋다.
2. 접근 한정자
    1) 코드의 노출 정도를 결정하는 한정자이다.
    2) 접근 한정자의 종류는 총 여섯 가지 이다.
        1] private : 클래스의 내부에서만 접근 가능
        2] protected : 클래스의 내부와 파생 클래스만 접근이 가능하다. 클래스의 외부에서 접근이 불가능하다. 
        3] public : 클래스의 외/내부 모두 접근 가능하다.
        4] internal : 같은 어셈블리에 있는 코드에서만 public으로 접근 가능
        5] protected internal : 같은 어셈블리에 있는 코드에서만 protected로 접근 가능
        6] private protected : 같은 어셈브리에 있는 클래스에서 상속받은 클래스 내부에서만 접근 가능
    3) 접근 한정자를 명시하지 않은 경우 무조건 private가 기본 설정으로 되어있다.

<7.8. 상속으로 코드 재활용하기>
1. 상속
    1) 클래스는 다른 클래스를 상속 받을 수 있다.
        - 상속이란 그 클래스의 멤버를 받는 것이다.
    2) 상속 받는 클래스를 '파생 클래스', 상속 하는 클래스를 '기반 클래스'라고 한다.
    3) 상속은 파생 클래스에서 클래스를 선언할 때 선언 부 뒤에 ': 상속받을 클래스'를 붙이면 된다.
        ex) class Child : Parent
    4) 파생 클래스에서 객체를 생성할 때 기반 클래스의 생성자를 호출한 뒤 파생 클래스의 객체를 생성한다.
    5) sealed 한정자를 사용하면 그 클래스는 상속을 하지 않는 봉인 클래스가 된다.9999999999999999999999++99999999999
2. 기반 클래스의 생성자
    1) base 키워드를 통해 기반 클래스의 멤버에 접근할 수 있다.
        ex) base.value = 3;
    2) base() 메소드를 생성자 옆에 : base() 형태로 붙여 기반 클래스의 생성자에 매개변수를 전달할 수 있다.
        ex) Child(int a, int b) : base(a)

<7.9. 기반 클래스와 파생 클래스 사이의 형식 변환, is와 as
1. 기반 클래스와 파생 클래스 사이의 형식 변환
    1) 기반 클래스와 파생 클래스 사이에서는 형식 변환이 가능하다.
        ex) Parent parent = new Parent() / parent = new Child() / Child child =+ (Child) parent;
2. is와 as
    1) is : 객체가 해당 형식인지를 구별하여 bool형식으로 리턴한다.
        ex) parent is Child는 true 반환 (위에서 parent = new Child())
    2) as : 형식 변환을 시도한 뒤 실패할 경우 null을 저장
        - 단, 참조 형식에서만 사용이 가능하다. (클래스 처럼)
        - 형식 변환에 실패하면 예외를 던지는 기존 형식 변환과 달리 null로 만들고 일단 코드를 실행하므로 코드 관리가 더 수월하다.
            > 가능한 형식 변환은 as를 사용하자

<7.10. 오버라이딩과 다형성>
1. 다형성 : 객체가 여러 형태를 가질 수 있음을 의미한다. 객체지향 프로그래밍의 3대 특징 중 하나이다.
    - 같은 이름의 메소드지만 어떤 객체로 부르냐에 따라 기능이 여러가지여서 이런 이름을 가졌다.
2. virtual
    1) virtual과 override
        - virtual : virtual 한정자가 있는 메소드는 파생 클래스에서 오버라이딩을 허용한다는 의미이다.
            > private 한정자가 있는 메소드는 어차피 파생 클래스에 전달되지 않기 때문에 virtual이 있어도 오버라이딩을 할 수 없다.
        - override : virtual 한정자가 있는 기반클래스의 메소드를 오버라이딩 한다는 의미의 한정자이다.

<7.11. 메소드 숨기기>
1. 메소드 숨기기
    1) 정의 : 기반 클래스의 메소드를 숨기고 파생 클래스의 메소드만 보여주어 마치 오버라이딩과 같은 효과를 볼 수 있는 기능이다.
    2) 방법 : new 한정자를 파생 클래스의 메소드에 붙여서 사용한다.
        ex) public new void MyMethod() { ... }
    3) 하지만, 클래스 간 형식 변환에서 적용되지 않는 등 오버라이딩과는 다르다.
        - 기반 클래스의 변수에 파생 클래스의 객체를 넣으면 기반 클래스의 메소드를 호출한다.

<7.12. 오버라이딩 봉인하기>
1. 오버라이딩 봉인
    1) 클래스를 상속하지 못하도록 봉인하듯 메소드도 오버라이딩을 못하게 봉인할 수 있다.
    2) 오버라이딩한 메소드에 sealed 한정자를 붙이면 된다.
    3) 단, virtual 메소드를 오버라이딩한 메소드에서만 가능하다.
        - virtual이나 override를 안한 메소드는 어차피 오버라이딩이 안되니까 필요 없다.
        - virtual을 붙인 메소드는 오버라이딩이 준비되었다는 의미이므로 필요 없다.
        - override가 있는 메소드는 오버라이딩이 준비 됐든 안됐든 무조건 오버라이딩이 가능한 메소드가 되므로 이를 보호하기 위해 봉인이 필요한 것이다.

<7.13. 읽기 전용 필드>
1. 읽기 전용 필드
    1) 정의 : 읽기만 가능한 필드이다.
    2) 기능 : 생성자 외 어디에서도 값 변경이 불가능한 필드이다.
        - 오직 생성자에서만 초기화가 가능하다.
    3) 방법 : 변수 앞에 한정자 readonly를 붙인다.
        ex) private readonly int min;

<7.14. 중첩 클래스>
1. 중첩 클래스
    1) 정의 : 클래스 안에 선언된 클래스
    2) 특징 : 자신이 소속된 클래스의 멤버를 자유롭게 사용 가능함
2. 중첩 클래스를 사용하는 이유
    1) 클래스 외부에 공개하고 싶지 않은 형식(자료형)을 만들고자 할 때
    2) 현재 클래스의 일부분처럼 표현할 수 있는 클래스를 만들고자 할 때 

<7.15. 분할 클래스>
1. 분할 클래스
    1) 정의 : 클래스를 여러 번 나눠서 구현하는 것
    2) 방법 : 클래스 이름 앞에 partial 키워드를 명시한다.
    3) 특징
        - 클래스의 구현이 길어질 경우 여러 파일에서 나눠 구현할 수 있게 해준다.
        - 소스 코드 관리 편의를 제공한다.
        - 컴파일 과정에서는 하나의 클래스로 보고 컴파일하기에 분할로 구현하던 통째로 구현하던 컴파일에서는 차이가 없다.

<7.16 확장 클래스>
1. 확장 클래스
    1) 정의 : 기존 클래스의 기능을 확장하는 기법이다.
    2) 방법
        1] static 한정자로 수식된 클래스를 선언해야 한다. (클래스 이름은 상관 없다.)
        2] static 한정자로 수식된 메소드를 선언해야 한다.
        3] 선언한 메소드의 첫 번째 매개변수는 'this 클래스명'이어야 한다.
        4] 두 번째 매개변수 부터 실제로 확장 메소드를 호출할 때 입력되는 매개변수이다.
    3) 예시
        public static class IntegerExtension
        {
            public static int Power(this int myInt, int a, int b)
            {
                ...
            }
        }
    4) 활용
        - int, string 같이 기본적으로 제공하는 클래스도 확장시킬 수 있다.
        - 다른 곳에서 가져오는 메소드를 외부파일인 이 곳에서 확장하는 것도 가능하다.

<7.17. 구조체>
1. 구조체
    1) 정의 : 데이터를 담기 위한 자료구조로 클래스와 유사하다.
    2) 선언 : struct 키워드를 이용해 선언한다.
    3) 특징
        - 클래스와 다르게 필드 한정자 선언을 안하면 기본적으로 public이 된다.
        - 값 형식이기 때문에 new 사용과 생성자가 필수적이 아니다.
            > 이로 인해 알아서 깊은 복사가 된다.
            > new를 사용하면 구조체의 생성자가 호출된다.
        - 생성자를 사용할 때는 반드시 매개변수가 필요하다. 
            > 매개변수가 없는 생성자는 필요 없는 존재이기 때문이다.
        - 상속은 불가능하다.
2. 변경 가능 객체 / 변경 불가능 객체
    1) 변경 가능 객체 : 상태(state)의 변화를 허용하는 객체
    2) 변경 불가능 객체 : 상태(state)의 변화를 허용하지 않는 객체
    3) 변경 불가능 객체의 장점
        - 멀티 쓰레드간 동기화를 신경 쓰지 않아도 되어 프로그램 성능이 향상된다.
        - 버그로 인한 데이터 오염을 막을 수 있다.
    4) 변경 불가능 구조체를 선언하려면 'readonly' 키워드를 앞에 기입하면 된다.
        ex) readonly struct test { ... }
    5) 변경 불가능 객체의 정보를 수정하고 싶으면 새로운 객체를 만들면 된다.

<7.18. 튜플>
1. 튜플
    1) 정의 : 즉석에서 사용할 복합 데이터 형식을 선언할 때 적합한 구조체이다.
    2) 선언 : var 변수명 = (필드1, 필드2, ...);
        - var을 선언해야 한다. 튜플 필드의 모양을 보고 형식을 결정하게 만들기 위함이다.
        ex) var tuple = (123, "PSJ", 789.2);
    3) 특징
        1] 필드의 이름을 지정할 수 있다.
            - 명명된 튜플 : var tuple = (Num : 123, Name : "PSJ, FLOAT : 789.2);
        2] 필드를 분해할 수 있다.
            - var (분해한 값을 저장할 변수들) = 튜플명
                ex) var(num, name, float) = tuple;
            - 특정 필드를 무시하려면 _를 사용한다.
                ex) var(num, _, float) = tuple;
    4) 튜플 분해를 이용해 여러 변수를 단번에 생성하고 초기화 할 수 있다.
        ex) var (name, age) = ("PSJ", 23);
2. 위치 패턴 매칭
    1) 식별자나 자료형이 아닌 분해된 요소의 위치에 따라 값이 일치하는지 판단하는 것
    2) 잘 모르겠으니 나중에 다시 해보자.


*/