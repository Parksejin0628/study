namespace Chapter07
{
    class mainApp
    {
        static void Main(string[] args)
        {


        }
    }
}

/*
[Chapter07 클래스]
<7.1. 객체지향 프로그래밍과 클래스>
1. 객체지향 프로그래밍
    1) 정의 : 코드 내의 모든 것을 객체로 표현하고자 하는 프로그래밍 패러다임
    2) 객체의 속성을 필드(Field), 기능을 메소드(Method)로 표현한다.
2. 클래스와 객체
    1) 클래스 : 객체를 만들기 위한 설계도같은 개념이다.
    2) 객체 : 클래스를 기반으로 만들어진 객체이다. 실체, 인스턴스(Instance)라고도 부른다.

<7.2. 클래스의 선언과 객체의 생성>
1. 클래스의 구성
    1) 멤버(Member) : 클래스 내에 선언된 요소들을 의미한다.
        - 필드(Field) : 클래스 안에 선언된 변수
        - 메소드(Method)
        - 이벤트(Event)
        - 프로퍼티
2. 객체 생성
    1) 생성자 : 객체를 생성하는 역할을 하는 메소드
        - 메소드의 이름이 클래스의 이름과 동일하다.
    2) 객체 생성 방법 : 클래스명 객체이름 = new 생성자
        ex) Cat kitty = new Cat();
        ex) Dog puppy = new Dog(2, "mandoo");
    3) 클래스는 복합 데이터 형식이다. 따라서, 객체명은 객체의 위치를 가리키는 참조형 변수이다.

<7.3. 객체의 삶과 죽음에 대하여>
1. 생성자
    1) 객체가 생성될 때 호출되는 메소드이다.
    2) 클래스와 이름이 같고 반환 형식이 없다.
        ex) class Test { ... public Text(int a) { ... } ... }
    3) 기본 생성자 : 생성자를 구현하지 않으면 컴파일러가 알아서 만들어주는 생성자.
        - 하지만, 객체 생성과 동시에 필드를 초기화 하고자 하면 생성자를 따로 구현하는 것이 좋다.
    4) 생성자도 오버로딩이 가능하다.
2. 종료자
    1) 가비지 컬렉터에 의해 객체가 소멸되는 시점에 호출되는 메소드이다.
    2) 클래스 이름 앞에 ~를 붙인 형태이며 한정자, 매개변수, 반환 형식이 모두 없다.
        ex) class Text { ... ~Text() { ... } ... }
    3) 여러 이유로 인해 가급적 사용하지 않는 것을 권한다.
        1] CLR의 가비지 컬렉터가 언제 동작할지 예측할 수 없다.
        2] 응용 프로그램의 성능 저하를 초래할 확률이 높다.
        3] 가비지 컬렉터로 객체의 소멸을 처리하는 것이 더 효율적이다.

<7.4. 정적 필드와 메소드>
1. 정적 필드
    1) 정적 필드 : 여러 개가 존재할 수 있는 인스턴스가 아닌 단 하나인 클래스에 소속되는 필드이다.
        - 필드 앞에 static 한정자를 붙여서 선언한다.
        - 단 하나뿐인 클래스에 소속되어 있으므로 그 프로그램에 단 하나뿐인 필드이다.
    2) 전역 변수처럼 사용하고 싶은 변수가 있다면 정적 필드를 이용하면 된다.
2. 정적 메소드
    1) 정적 메소드 : 클래스에 소속되는 메소드이다.
        - 정적 필드와 마찬가지로 static 한정자를 붙여서 선언하며 단 하나뿐이다.
    2) 인스턴스 메소드 : 정적 메소드가 아니라 인스턴스에 소속된 메소드이다.
        - 반드시 인스턴스가 생성되어야 사용할 수 있는 인스턴스이다.
    3) 정적 메소드의 활용 : 인스턴스의 필드를 이용하지 않는 메소드는 보통 정적 메소드로, 이용하는 경우 인스턴스 메소드로 사용한다.

<7.5. 객체 복사하기 : 얕은 복사와 깊은 복사>
1. 얕은 복사
    1) 단순히 인스턴스 변수를 선언한 후 이미 있는 인스턴스를 복사하면 같은 인스턴스를 가리키게 된다.
        - 인스턴스는 참조 형식을 사용하기 때문에 인스턴스 복사가 아닌 주소 값을 복사하는 것이기 때문이다.
    2) 얕은 복사 : 단순히 주소만 복사하는 경우를 의미한다.
2. 깊은 복사
    1) 인스턴스의 내용을 복사해서 받아 별도의 힙 공간에 보관하는 것이다.
    2) C#에서 기본적으로 제공하는 것이 없기에 새로운 공간을 할당해서 주소 값을 리턴하는 식으로 깊은 복사를 구현한다.

<7.6. this 키워드>
1. this
    1) this 키워드는 객체가 자신을 가리킬 때 사용하는 키워드이다.
        ex) this.value = 3;
    2) 다른 클래스의 멤버와 이름이 겹치는 경우 누군가를 가리키는지 알 수 없는 모호함을 해결할 때 많이 사용한다.
2. this() 생성자
    1) this()는 자기 자신의 생성자를 가리키는 메소드이다.
    2) this()는 생성자에서만 사용할 수 있으며 그 중에서도 생성자 선언부 뒤에 : this()로 선언한다.
        ex) public MyClass(int b, int c) : this(b) { ... }

<7.7. 접근 한정자로 공개 수준 결정하기>
1. 은닉성(Encapsulation)
    1) 클래스의 사용자에게 최소한의 기능만 노출하고 나머지는 숨기는 것이다.
    2) 객체지향 프로그래밍의 3대 특성 중 하나이다.
    3) 특히 필드는 상수를 제외하고 무조건 숨기는 것이 좋다.
2. 접근 한정자
    1) 코드의 노출 정도를 결정하는 한정자이다.
    2) 접근 한정자의 종류는 총 여섯 가지 이다.
        1] private : 클래스의 내부에서만 접근 가능
        2] protected : 클래스의 내부와 파생 클래스만 접근이 가능하다. 클래스의 외부에서 접근이 불가능하다. 
        3] public : 클래스의 외/내부 모두 접근 가능하다.
        4] internal : 같은 어셈블리에 있는 코드에서만 public으로 접근 가능
        5] protected internal : 같은 어셈블리에 있는 코드에서만 protected로 접근 가능
        6] private protected : 같은 어셈브리에 있는 클래스에서 상속받은 클래스 내부에서만 접근 가능
    3) 접근 한정자를 명시하지 않은 경우 무조건 private가 기본 설정으로 되어있다.

<7.8. 상속으로 코드 재활용하기>
1. 상속
    1) 클래스는 다른 클래스를 상속 받을 수 있다.
        - 상속이란 그 클래스의 멤버를 받는 것이다.
    2) 상속 받는 클래스를 '파생 클래스', 상속 하는 클래스를 '기반 클래스'라고 한다.
    3) 상속은 파생 클래스에서 클래스를 선언할 때 선언 부 뒤에 ': 상속받을 클래스'를 붙이면 된다.
        ex) class Child : Parent
    4) 파생 클래스에서 객체를 생성할 때 기반 클래스의 생성자를 호출한 뒤 파생 클래스의 객체를 생성한다.
    5) sealed 한정자를 사용하면 그 클래스는 상속을 하지 않는 봉인 클래스가 된다.
2. 기반 클래스의 생성자
    1) base 키워드를 통해 기반 클래스의 멤버에 접근할 수 있다.
        ex) base.value = 3;
    2) base() 메소드를 생성자 옆에 : base() 형태로 붙여 기반 클래스의 생성자에 매개변수를 전달할 수 있다.
        ex) Child(int a, int b) : base(a)

<7.9. 기반 클래스와 파생 클래스 사이의 형식 변환, is와 as
1. 기반 클래스와 파생 클래스 사이의 형식 변환
    1) 기반 클래스와 파생 클래스 사이에서는 형식 변환이 가능하다.
        ex) Parent parent = new Parent() / parent = new Child() / Child child = (Child) parent;
2. is와 as
    1) is : 객체가 해당 형식인지를 구별하여 bool형식으로 리턴한다.
        ex) parent is Child는 true 반환 (위에서 parent = new Child())
    2) as : 형식 변환을 시도한 뒤 실패할 경우 null을 저장
        - 단, 참조 형식에서만 사용이 가능하다. (클래스 처럼)
        - 형식 변환에 실패하면 예외를 던지는 기존 형식 변환과 달리 null로 만들고 일단 코드를 실행하므로 코드 관리가 더 수월하다.
            > 가능한 형식 변환은 as를 사용하자




*/