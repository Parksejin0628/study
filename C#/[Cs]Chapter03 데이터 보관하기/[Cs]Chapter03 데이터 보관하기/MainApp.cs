using System;

namespace main
{
    class MainApp
    {
        static void Main(string[] args)
        {
            //정수 형식 예제
            sbyte a = -10;
            byte b = 40;

            Console.WriteLine($"a = {a}, b = {b}");

            short c = -30000;
            ushort d = 60000;

            Console.WriteLine($"c = {c}, d = {d}");

            int e = -100_0000;
            uint f = 3_0000_0000;

            Console.WriteLine($"e = {e}, f = {f}");

            long g = -5000_0000_0000;
            ulong h = 200_0000_0000_0000_0000;

            Console.WriteLine($"g = {g}, h = {h}");
        }
    }
}

/* [Chapter03 데이터 보관하기]
 * <3.1 다양한 데이터의 종류>
 *  1. C#은 데이터 처리를 위해 기본 데이터 형식과 복합 데이터 형식을 제공한다.
 *      - 기본 데이터 형식 : int, double, char, bool 등
 *      - 복합 데이터 형식 : 구조체, 클래스, 배열 등
 * <3.2 변수>
 *  1. 변수 : 값을 대입시켜 변화시킬 수 있는 요소 / 데이터를 담는 일정 크기의 공간
 *      1) 변수 사용 방법
 *          - 변수 선언 방식 : int x;
 *          - 변수 값 대입 : x = 30;
 *      2) 변수는 선언과 동시에 초기화가 가능하다.
 *          ex) int x = 30;
 *      3) 변수 여러 개를 동시에 선언 및 초기화가 가능하다. 단, 콤마로 구분해 주어야 한다.
 *          ex) int x, y, z;
 *          ex) int x = 30, y = 40, z = 50;
 *  2. C#은 변수를 초기화 하지 않으면 사용할 수 없다.
 *      - 쓰레기 값을 사용하는 것을 미연에 방지하는 것이다.
 *  3. 리터럴(Literal) : 코드에 있는 고정된 값을 지칭하는 단어이다. 주로 대입 연산자 오른쪽에 존재한다.
 *      ex) int x = 30; 에서 30이 리터럴이다.
 *      ex) string s = "가나다" 에서 "가나다"가 리터럴이다.
 * <3.3 값 형식과 참조 형식>
 *  1. 스택 영역
 *      1) 특징
 *          - 데이터를 차례대로 쌓아 저장하는 데이터 영역이다.
 *          - 특정 블록 안에서만 존재하며 '}'를 만나면 차례대로 메모리가 반환된다.
 *          - 블록 밖에서는 데이터를 사용할 수 없다는 단점이 존재한다.
 *  2. 힙 영역
 *      1) 특징
 *          - 블록에 영향을 받지 않는 데이터 영역이다.
 *          - 스택과 다르게 자동으로 메모리 반환을 하지는 않는다.
 *          - 스택 영역과 다르게 블록 밖에서도 데이터를 유지할 수 있다.
 *      2) 가비지 컬렉터(Garbage Collector) : 자동으로 메모리를 반환하지 않는 힙 영역에 단점을 보완하기 위한 CLR의 기능이다. 
 *          - 힙 영역에 있는 데이터 중 사용하지 않는다고 판단한 데이터(해당 데이터를 참조하는 곳이 없을 때)의 메모리를 반환한다.
 *  3. 데이터 저장 방식
 *      1) 값 형식(value type) : 값 그 자체를 저장하는 형식이다. 스택 영역에 저장된다.
 *      2) 참조 형식(reference type) : 변수가 값이 있는 위치를 담는 데이터 형식이다. (즉, 데이터가 담긴 곳을 참조하는 형식이다.) 
 *          - 힙 영역에 실제 사용하는 데이터를 저장한다.
 *          - 스택 영역에는 힙 영역에 있는 데이터를 가리키는 주소값을 저장한다.
 * <3.4 기본 데이터 형식>
 *  1. 정수 데이터 형식
 *      1) C#에서는 코드에 사용할 데이터의 범위에 맞춰 메모리를 효율적으로 사용할 수 있도록 다양한 숫자 데이터 형식을 제공한다. 정수 데이터 형식은 총 9가지 이다.
 *      2) 정수 데이터 형식 종류 (s 는 signed, u 는 unsigned의 줄임말이다.)
 *          - byte      : 1바이트  / 0 ~ 255
 *          - sbyte     : 1바이트  / -128 ~ 127
 *          - short     : 2 바이트 / -32,768 ~ 32,767
 *          - ushort    : 2 바이트 / 0 ~ 65,535
 *          - int       : 4 바이트 / -2,147,483,648 ~ 2,147,483,647
 *          - uint      : 4 바이트 / 0 ~ 4,294,967, 295
 *          - long      : 8 바이트 / -922,337,203,685,477,508 ~ 922,337,203,685,477,507
 *          - ulong     : 8 바이트 / 0 ~ 18,446,744,073,709,551,615
 *          - char      : 2 바이트 / 유니코드 문자
 *      3) 정수 리터럴을 타이핑 할 때 자릿수 구분자 _ 를 이용하면 편리하다.
 *          ex) x = 1_000_000;
 *      4) 2진수, 16진수 리터럴을 10진수 리터럴과 구분하기 위해 2진수 앞에는 0b, 16진수 앞에는 0x 접두사를 이용한다.
 *          ex) 10의 경우 
 *                  2진수 : 0b1010
 *                  16진수 : 0xa
 *      5) 데이터 형식의 크기를 넘어선 값을 넘으면 오버플로가 발생한다. (크기보다 작은 값을 넣으면 언더플로)
 *      
 *  2. 부동 소수점 형식
 *      1) 부동 소수점 형식은 소수점을 이동시켜(부동) 수를 표현하여 실수를 표현하는 형식이다.
 *          - 소수점을 움직이며 표현하면 제한된 비트로 더 많은 수를 표현할 수 있다.
 *      2) 정수 표현을 위해 부동 소수점 형식을 사용하지 않는 이유는 크게 두 가지이다.
 *          - 같은 크기의 정수 표현에 비해 표현 가능한 정수 범위가 더 한정적이다.
 *          - 산술 연산 과정이 복잡하기에 더 느리다.
 *      3) 부동 소수점 형식 종류
 *          - float     : 4바이트  / -3.402823e38 ~ 3.402823e38
 *          - double    : 8바이트  / -1.797693134862632e308 ~ 1.797693134862632e308
 *          - decimal   : 16바이트 / 29자리 데이터를 표현 가능
 *      4) 부동 소수점 형식 주의점
 *          - 부동 소수점 형식은 부호, 지수부, 가수부로 나뉘어 가수부에 지수부만큼 제곱하는 방식으로 표현한다.
 *              > 따라서, 정밀도가 한정되어 있다.
 *              > 데이터 손실에 주의해야 한다.
 *          - double이 float보다 더 많은 수를 표현 가능하기에 데이터 손실의 최소화를 위해 float 보다는 double을 사용하는 것이 권장된다.
 *  3. 문자 형식과 문자열 형식
 *      1) char : 문자를 담는 변수이다. ' '를 통해 데이터를 입력한다.
 *          ex) char a = '가'
 *      2) string : 문자열을 담는 변수이다. " "를 통해 데이터를 입력한다.
 *          ex) string a = "안녕하세요?"
 *  4. 논리 형식
 *      - 논리 형식은 참, 거짓을 다루는 데이터이다.
 *          > True : 참
 *          > False : 거짓 
 *  5. object 형식
 *      1) object 형식은 어떤 데이터든 다룰 수 있는 데이터 형식이다.
 *      2) object 형식은 모든 데이터 형식을 유도클래스로 두기 떄문에 (즉, 모든 데이터 형식이 object를 상속받기 때문에) 어떤 데이터든 담을 수 있다.
 *          - C++에서 배웠듯 기초클래스로 선언한 포인터는 유도클래스를 가리킬 수 있는 것과 같은 논리이다.
 *  6. 박싱, 언박싱
 *      1) object 형식은 참조 형식이기 대문에 힙에 데이터를 저장한다. (스택에 저장된 데이터는 힙에 저장된 데이터공간을 가리키는 주소값이다.)
 *      2) 이렇게 스택 영역에 저장된 데이터를 object 형식을 통해 입 영역에 저장하는 것을 '박싱'이라고 한다. (boxing, 데이터를 힙에 담는다.)
 *      3) 언박싱은 힙에 저장된 데이터를 스택의 영역으로 가져와 저장하는 것을 의미한다.
 *  7. 형식 변환
 *      - 변수를 다른 데이터 형식으로 옮겨 담는 것을 형식 변환이라고 한다. 책에서는 5가지 상황에서의 형식 변환을 설명하고 있다.
 *      1) 크기가 서로 다른 정수 형식 사이의 변환
 *          - 크기가 작은 형식에서 큰 형식으로 변환은 큰 문제가 없다.
 *          - 크기가 큰 형식에서 작은 형식으로 변환 시 작은 형식의 범위보다 큰 정수가 들어올 경우 오버플로가 발생하는 것에 주의해야 한다.
 *      2) 크기가 서로 다른 부동 소수점 형식 사이의 변환
 *          - 부동 소수점 형식은 지수부, 가수부를 이용하는 형식 상 오버플로 자체는 발생하지 않는다.
 *          - 하지만, 부동 소수점 형식 사이의 변환은 정밀성에 큰 타격을 준다.
 *          - 부동 소수점 형식 사이에서 변환을 할 때는 2진수로 저장된 데이터를 10진수로 변환한 뒤 다시 2진수로 변환한다. 하지만, 2진수로 표현된 데이터를 10진수로 바꿀 때 소수가 완전하지 않기 때문에 이러한 문제가 발생한다.
 *              ex) 1/3 같은 숫자는 0.3333333... 이라는 무한 소수가 되기 때문에 완전한 소수가 아니고, 이러한 변환을 거칠 때 데이터 손상이 나게 된다.
 *          - 데이터 손실을 방지하기 위해 부동 소수점 형식 사이의 변환은 자제해야 할 것이다.
 *      3) 부호 있는 정수 형식과 부호 없는 정수 형식 사이의 변환
 *          - 부호 있는 정수 형식에 음수가 저장되어 있었을 경우 부호 없는 정수 형식으로 변환하면 언더플로우가 발생한다.
 *      4) 부동 소수점 형식과 정수 형식 사이의 변환
 *          - 부동 소수점 형식에서 정수 형식으로 변환할 경우 소수점 이하를 전부 버린다.
 *          - 정수 형식에서 부동 소수점 형식으로 변환하면 그냥 소수점 이하 값이 없는 부동 소수점 형식으로 된다.
 *      5) 문자열과 숫자 사이의 변환
 *          - 일반적인 '(', ')'을 이용한 형식 변환은 사용할 수 없다.
 *          - 문자열을 숫자로 바꾸려면 숫자 데이터 형식에 있는 Parse() 메소드를 사용해야 한다.
 *              ex) int a = int.Parse("12345");
 *                  float b = float.Parse("123.45");
 *          - 숫자를 문자열로 바꾸려면 object형식에 있는 ToString() 메소드를 사용해야 한다.
 *              ex) int c = 12345;
 *                  string d = c.Tostring();
 * <3.5 상수와 열거 형식>
 *  1. 상수
 *      1) 상수가 필요한 이유
 *          - 프로그램을 만들다 보면 값이 변하지 않는 변수가 필요하다.
 *          - 프로그래머는 사람이기 때문에 바꾸면 안되는 변수를 건드는 실수를 할 수 있다. 이러한 실수를 방지하기 위해 상수라는 개념을 따로 만들었다.
 *      2) 상수 사용 방법
 *          - 변수 선언 과정과 같으나 앞에 const를 붙여야 한다. 또한, 선언과 동시에 초기화를 해야 한다.
 *              ex) const int a = 30;
 *  2. 열거형
 *      1) 열거 형식이 필요한 이유
 *          - 수 많은 상수를 다루다 보면 값이 중복되는 실수가 발생할 수 있다. 이러한 실수는 프로그램에 큰 악영향을 미치므로 이를 방지하기 위한 개념이다.
 *      2) 열거 사용 방법
 *          - enum 열거 형식명 : 기반자료형 ( 상수 1, 상수 2, 상수 3, ... }
 *              > 기반 자료형에는 정수 형식만 가능하며 생략할 경우 int로 한다.
 *              ex) enum DialogResult {YES, NO, CANCEL, CONFIRM, OK)
 *      3) 열거 형식의 특징
 *          - 각 상수에는 임의의 값을 저장할 수 있다.
 *              ex) enum Dialog { YES = 10 , NO = 20 }
 *          - 임의의 값을 저장하지 않을 경우 0부터 1씩 증가하며 값을 저장한다.
 *              ex) enum Dialog { YES, NO, CANCEL } 에서 YES = 0, NO = 1, CANCLE = 2가 저장한다.
 *                  > 중복되지 않는 것이 중요하기에 값은 편하게 0부터 대입하는 것이다.
 *          - 임의의 값을 몇몇만 저장할 경우 저장하지 않은 상수는 이전 값 + 1을 저장하게 된다.
 *              ex) enum Dialog { YES = 10, NO, CANCEL, CONFIRM = 50, OK } 인 경우 YES = 10, NO = 11, CANCEL = 12, CONFIRM = 50, OK = 51이 된다.
 *          - 열거 형식이기에 자료형 처럼 사용할 수 있으며 열거형의 상수는 . 을 사용해 접근한다.
 *              ex) Dialog result = Dialog.NO;
 *              
 * 
 * 
 * 
 * 
 */