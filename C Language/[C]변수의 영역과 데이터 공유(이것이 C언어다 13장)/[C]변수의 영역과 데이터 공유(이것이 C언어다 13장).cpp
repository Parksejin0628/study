#include<stdio.h>

void func1_1();
void func1_2();
void func3_1();
void func3_2();
void func4_1();
void func4_2();
void func5_1(int a, int b);
void func5_2(int *a, int *b);
int* func6_1();

int globalVar;

int main(void)
{
	int a = 10;
	int b = 20;
	int i = 0;
	int *pa;
	
	printf("(1)\n");
	func1_1();
	func1_2();
	//서로 다른 함수에서는 지역 변수의 이름이 같더라도 충돌하지 않는다. 
	printf("\n(2)\n");
	printf("블록 통과 전 a값 : %d, b값 : %d\n", a, b);
	{
		int a, b;
		
		a = 50;
		b = 70;
		printf("블록 안에서의 a값 : %d, b값 : %d\n", a, b);
	}
	printf("블록 통과 후 a값 : %d, b값 : %d\n", a, b);
	//블록 안에서 선언한 지역 변수는 사용 범위가 해당 블록으로만 제한된다. 또한, 같은 이름의 변수가 있을 경우 가장 가까운 블록에 선언된 변수를 사용한다.
	printf("\n(3)\n");
	printf("초기화 하지 않았을 때 globalVar의 값 : %d\n", globalVar);
	func3_1();
	printf("첫 번째 함수 통과 후 globalVar의 값 : %d\n", globalVar);
	func3_2();
	printf("두 번재 함수 통과 후 globalVar의 값 : %d\n", globalVar);
	//전역 변수는 초기화 하지 않아도 0으로 자동 초기화 된다. 또한, 모든 함수에서 사용할 수 있다. 만약 전역변수의 이름과 지역 변수의 이름이 같을 경우 지역 변수를 우선으로 사용한다. 
	printf("\n(4)\n");
	for(i=0; i<5; i++)
	{
		func4_1();
		func4_2();	
	} 
	//정적 지역 변수는 함수가 반환되더라도 저장 공간이 유지되므로 하나의 함수를 여러 번 호출할 때 같은 변수로 사용할 수 있다. 
	printf("\n(5)\n");
	a = 5;
	b = 8;
	printf("함수 통과 전 a의 값 : %d, b의 값 : %d\n", a, b);
	func5_1(a, b);
	printf("값을 복사해 호출하는 함수를 통과한 후 a의 값 : %d, b의 값 : %d\n", a, b);
	func5_2(&a, &b);
	printf("주소를 복사해 호출하는 함수를 통과한 후 a의 값 : %d, b의 값 : %d\n", a, b); 
	//값을 복사해서 전달하는 함수는 호출해도 호출한 함수의 변수값 즉, 이곳 main함수의 변수값에 영향을 주지 않지만 주소를 복사해서 전달하는 함수는 호출한 함수의 변수값  즉, 이곳 main함수의 변수값에 영향을 준다. 
	printf("\n(6)\n");
	pa = func6_1();
	printf("현재 함수 재호출 전 main함수에서 구한 res값 : %d\n", *pa);
	*pa += 10;
	printf("main함수에서 res에 값 변화\n");
	pa = func6_1();
	printf("현재 함수 재호출 후 main함수에서 구한 res값 : %d\n", *pa);
	//정적변수나 전역변수인 경우 해당 함수에서 사용된 변수의 주소값을 반환함으로써 해당 변수를 다른 호출한 함수에서도 사용할 수 있고 심지어 영향도 줄 수 있다. 
	
	scanf("%d");
	
	return 0;
}

void func1_1()
{
	int a = 20;
	printf("1번 함수의 a 값 : %d\n",a);
	
	return;
}

void func1_2()
{
	int a = 30;
	printf("2번 함수의 a 값 : %d\n",a);
	
	return;
}

void func3_1()
{
	globalVar = 20;
	printf("첫 번째 함수 안에서 globalVar의 값 : %d\n", globalVar);
	
	return;
}

void func3_2()
{
	int globalVar = 50;
	printf("두 번째 함수 안에서 globalVar으 값 : %d\n", globalVar);
	
	return;
}

void func4_1()
{
	int num = 0;
	num++;
	printf("일반 지역 변수를 사용한 함수의 num 값 : %d\n", num);
}

void func4_2()
{
	static int num = 0;
	num++;
	printf("정적 지역 변수를 사용한 함수의 num 값 : %d\n", num);
}

void func5_1(int a, int b)
{
	a = 50;
	b = 80;
	
	return;
} 

void func5_2(int *a, int *b)
{
	*a = 50;
	*b = 80;
	
	return;
}

int* func6_1()
{
	static int res;
	printf("현재 호출된 함수에서의 res의 값 : %d\n", res);
	
	return &res;
}

/*
[13장 변수의 영역과 데이터 공유]
<13.1 변수 사용 영역>
	13.1.1 지역 변수
		- 지역변수(local variable)는 변수의 종류를 나타내는 auto 예약어와 함께 함수 안에 선언하며 auto는 생략할 수 있다.(즉, 그동안 쓰던 지역변수는 전부 auto 예약어가 사용된 변수이다.)
		- 지역 변수는 사용 범위가 블록 내부로 제한된다.  (지역 변수로 선언한 변수는 다른 함수에서 사용할 수 없다.)
			> 따라서, 서로 다른 함수에 같은 이름의 지역 변수를 선언해도 이름이 서로 충돌하지 않는다.
			> 이는 지역 변수의 이름이 같더라도 선언된 함수가 다르면 각각 독립된 저장 공간을 갖는다는 의미이다.
		- 지역 변수의 사용 범위를 함수 단위로 제한하고 독립된 저장 공간을 확보하면 2개의 장점을 가진다.
			> 1. 메모리를 효율적으로 사용할 수 있다 - 지역 변수는 함수가 반환될 경우 지역 변수에 할당된 저장 공간을 자동으로 회수하여 재활용한다.
			> 2. 디버깅에 유리하다 - 지역 변수는 값에 문제가 있을 때 해당 변수가 있는 함수에서 원인을 찾으면 되므로 수정하기 쉽다.
		- 지역 변수는 자동으로 초기화가 되지 않으며 사용 범위가 하나의 함수로 제한되므로 불편하지만 장점이 더 크므로 최우선으로 사용해야 한다.
	13.1.2 블록 안에서 사용하는 지역 변수 
		- 지역 변수는 보통 함수 안에서 선언한 후 함수 끝까지 사용하지만 선언 위치에 따라 사용 범위가 달라질 수 있다.
		- 특정 블록 안에 변수를 선언하면 사용 범위가 그 블록 내부로 제한된다.
		- 같은 이름의 사용 가능한 변수가 둘 이상일 경우 가장 가까운 블록에 선언된 변수를 사용한다.
			>하지만, 중첩된 블록에서 같은 이름의 변수를 선언하는 것은 지양해야 한다. 
	13.1.3 전역 변수
		- 함수 밖에 변수를 선언하면 전역 변수(global variable)이다.
		- 전역 변수의 사용 범위는 프로그램 전체이다. 즉, 어떤 함수라도 안에서 직접 사용할 수 있다.
		- 전역 변수는 특정 함수 안에 있는 것이 아니므로 프로그램이 실행될 때 메모리에 할당되고 프로그램이 끝날 때까지 존재한다.
		- 전역 변수는 초기화를 하지 않아도 0으로 자동 초기화 된다.
		- 전역 변수와 지역 변수의 이름이 같을 경우 지역 변수를 먼저 사용한다.
		- 전역 변수는 모든 함수에서 자유롭게 접근할 수 있으므로 같은 변수를 여러 함수에서 쉽게 공유할 수 있지만, 이러한 특징이 장점 보다 부작용이 더 크므로 사용을 꺼리게 된다. 
			> 전역 변수의 이름을 바꾸면 그 변수를 사용하는 모든 함수를 찾아 수정해야 한다.
			> 전역 변수의 값이 잘못된 경우 접근 가능한 모든 함수를 의심해야 한다.
			> 코드 블록 내에 같은 이름의 지역 변수를 선언하면 그 영역에서는 전역 변수를 사용할 수 없다. 
	13.1.4 정적 지역 변수
		- 지역 변수를 사용할 때 static 예약어를 사용하면 정적 지역 변수가 된다. (static variable)
		- 정적 지역 변수 또한 지역 변수이므로 사용 범위가 블록 내로 제한된다.
		- 하지만, 정적 지역 변수는 선언된 함수가 반환되더라도 저장 공간을 계속 유지한다.
			> 전역 변수와 유사하게 프로그램이 실행될 때 메모리에 할당되며 프로그램이 끝날 때 까지 존재한다. 
			> 또한, 0으로 자동 초기화된다. 
			> 즉, 정적 지역 변수는 블록 안에서만 사용할 수 있는 전역 변수와 같다. 
			> 이러한 특징으로 하나의 함수가 여러 번 호출되는 경우 같은 변수를 공유할 수 있다. 
	13.1.5 레지스터 변수
		- 지역 변수에 예약어 register를 사용할 경우 레지스터 변수(register variable)를 선언할 수 있다. 
		- 레지스터 변수는 CPU 안에 있는 저장 공간인 레지스터를 사용한다.
			> 레지스터는 CPU안에 있기 때문에 데이터 처리 속도가 가장 빠른 저장 공간이다.
			> 따라서, 사용 횟수가 많은 경우 실행 시간을 줄일 수 있다.
		- 레지스터 변수는 저장공간이 메모리에 있는 것이 아니라 CPU의 자원을 잠깐 빌리는 것이다.
			> 따라서, 전역 변수는 레지스터로 할당할 수 없다.
			> 또한, 주소 연산자를 써서 포인터를 구할 수 없다.
		- 레지스터 변수로 사용하다 하더라도 컴파일러가 레지스터와 메모리 중 어디에 할당하는 것이 이득인지 판단하여 사용 여부를 결정한다. 
<13.2 함수의 데이터 공유 방법>
	13.2.1 값을 복사해서 전달하는 방법
		- 함수를 호출할 때 필요한 데이터를 전달하는 가장 일반적인 방법은 값을 복사해서 넘겨주는 방식이다.
			>func(a,b)처럼 a, b 변수의의 값을 복사해서 함수에 넘기는 방법이다.
		- 해당 함수를 호출한 함수에 있는 변수에는 영향을 주지 않는다.
		- 값을 출력하거나 연산하는 경우와 같이 호출하는 함수의 값을 바꿀 필요가 없는 경우에 주로 사용한다.
	13.2.2 주소를 전달하는 방법
		- 함수를 호출할 때 처리할 변수의 주소를 전달하는 방법이다.
			>func(&a, &b)처럼 a, b 변수의 주소를 함수에 넘기는 방법이다.
		- 해당 함수를 호출한 함수에 있는 변수의 값을 바꿀 수 있다.
			ex) 만약 main함수에서 변수 a의 주소로 넘긴 함수를 호출한 후 함수에서 a값을 바꾼 경우 함수를 호출한 main함수에 있는 a 값이 변한다. 
		- 호출하는 함수에 있는 변수 값을 바꿀 필요가 있을 경우 사용한다.
	13.2.3 주소를 반환하는 함수
		- 반환값이 있는 함수는 호출한 함수로 값을 복사해서 반환한다.
			> 함수가 반환되면서 함수 안에서 사용한 지역 변수의 저장 공간이 사라지므로 값을 복사해서 반환한다.
		- 하지만, 변수의 저장 공간이 계속 유지되는 정적 변수와 전역 변수는 주소를 반환할 수 있다.
		- 주소를 반환함으로써 언제든 간접참조를 통해 해당 값을 사용할 수 있고 심지어 값을 바꿀 수도 있다.
		- 반환값의 자료형은 반환값을 저장할 포인터의 자료형과 같아야 한다.
		- 지역 변수의 경우 함수가 반환된 후 저장 공간이 회수되어 언제 다른 용도로 사용될지 모르기 때문에 지역 변수의 주소는 반환해서는 안된다. 
	
*/
