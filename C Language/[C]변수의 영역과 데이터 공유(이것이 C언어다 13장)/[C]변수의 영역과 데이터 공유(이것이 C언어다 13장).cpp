#include<stdio.h>

void func1_1();
void func1_2();
void func3_1();
void func3_2();
void func4_1();
void func4_2();

int globalVar;

int main(void)
{
	int a = 10;
	int b = 20;
	int i = 0;
	
	printf("(1)\n");
	func1_1();
	func1_2();
	//서로 다른 함수에서는 지역 변수의 이름이 같더라도 충돌하지 않는다. 
	printf("\n(2)\n");
	printf("블록 통과 전 a값 : %d, b값 : %d\n", a, b);
	{
		int a, b;
		
		a = 50;
		b = 70;
		printf("블록 안에서의 a값 : %d, b값 : %d\n", a, b);
	}
	printf("블록 통과 후 a값 : %d, b값 : %d\n", a, b);
	//블록 안에서 선언한 지역 변수는 사용 범위가 해당 블록으로만 제한된다. 또한, 같은 이름의 변수가 있을 경우 가장 가까운 블록에 선언된 변수를 사용한다.
	printf("\n(3)\n");
	printf("초기화 하지 않았을 때 globalVar의 값 : %d\n", globalVar);
	func3_1();
	printf("첫 번째 함수 통과 후 globalVar의 값 : %d\n", globalVar);
	func3_2();
	printf("두 번재 함수 통과 후 globalVar의 값 : %d\n", globalVar);
	//전역 변수는 초기화 하지 않아도 0으로 자동 초기화 된다. 또한, 모든 함수에서 사용할 수 있다. 만약 전역변수의 이름과 지역 변수의 이름이 같을 경우 지역 변수를 우선으로 사용한다. 
	printf("\n(4)\n");
	for(i=0; i<5; i++)
	{
		func4_1();
		func4_2();	
	} 
	//정적 지역 변수는 함수가 반환되더라도 저장 공간이 유지되므로 하나의 함수를 여러 번 호출할 때 같은 변수로 사용할 수 있다. 
		
	
	scanf("%d");
	
	return 0;
}

void func1_1()
{
	int a = 20;
	printf("1번 함수의 a 값 : %d\n",a);
	
	return;
}

void func1_2()
{
	int a = 30;
	printf("2번 함수의 a 값 : %d\n",a);
	
	return;
}

void func3_1()
{
	globalVar = 20;
	printf("첫 번째 함수 안에서 globalVar의 값 : %d\n", globalVar);
	
	return;
}

void func3_2()
{
	int globalVar = 50;
	printf("두 번째 함수 안에서 globalVar으 값 : %d\n", globalVar);
	
	return;
}

void func4_1()
{
	int num = 0;
	num++;
	printf("일반 지역 변수를 사용한 함수의 num 값 : %d\n", num);
}

void func4_2()
{
	static int num = 0;
	num++;
	printf("정적 지역 변수를 사용한 함수의 num 값 : %d\n", num);
}

/*
[13장 변수의 영역과 데이터 공유]
<13.1 변수 사용 영역>
	13.1.1 지역 변수
		- 지역변수(local variable)는 변수의 종류를 나타내는 auto 예약어와 함께 함수 안에 선언하며 auto는 생략할 수 있다.(즉, 그동안 쓰던 지역변수는 전부 auto 예약어가 사용된 변수이다.)
		- 지역 변수는 사용 범위가 블록 내부로 제한된다.  (지역 변수로 선언한 변수는 다른 함수에서 사용할 수 없다.)
			> 따라서, 서로 다른 함수에 같은 이름의 지역 변수를 선언해도 이름이 서로 충돌하지 않는다.
			> 이는 지역 변수의 이름이 같더라도 선언된 함수가 다르면 각각 독립된 저장 공간을 갖는다는 의미이다.
		- 지역 변수의 사용 범위를 함수 단위로 제한하고 독립된 저장 공간을 확보하면 2개의 장점을 가진다.
			> 1. 메모리를 효율적으로 사용할 수 있다 - 지역 변수는 함수가 반환될 경우 지역 변수에 할당된 저장 공간을 자동으로 회수하여 재활용한다.
			> 2. 디버깅에 유리하다 - 지역 변수는 값에 문제가 있을 때 해당 변수가 있는 함수에서 원인을 찾으면 되므로 수정하기 쉽다.
		- 지역 변수는 자동으로 초기화가 되지 않으며 사용 범위가 하나의 함수로 제한되므로 불편하지만 장점이 더 크므로 최우선으로 사용해야 한다.
	13.1.2 블록 안에서 사용하는 지역 변수 
		- 지역 변수는 보통 함수 안에서 선언한 후 함수 끝까지 사용하지만 선언 위치에 따라 사용 범위가 달라질 수 있다.
		- 특정 블록 안에 변수를 선언하면 사용 범위가 그 블록 내부로 제한된다.
		- 같은 이름의 사용 가능한 변수가 둘 이상일 경우 가장 가까운 블록에 선언된 변수를 사용한다.
			>하지만, 중첩된 블록에서 같은 이름의 변수를 선언하는 것은 지양해야 한다. 
	13.1.3 전역 변수
		- 함수 밖에 변수를 선언하면 전역 변수(global variable)이다.
		- 전역 변수의 사용 범위는 프로그램 전체이다. 즉, 어떤 함수라도 안에서 직접 사용할 수 있다.
		- 전역 변수는 특정 함수 안에 있는 것이 아니므로 프로그램이 실행될 때 메모리에 할당되고 프로그램이 끝날 때까지 존재한다.
		- 전역 변수는 초기화를 하지 않아도 0으로 자동 초기화 된다.
		- 전역 변수와 지역 변수의 이름이 같을 경우 지역 변수를 먼저 사용한다.
		- 전역 변수는 모든 함수에서 자유롭게 접근할 수 있으므로 같은 변수를 여러 함수에서 쉽게 공유할 수 있지만, 이러한 특징이 장점 보다 부작용이 더 크므로 사용을 꺼리게 된다. 
			> 전역 변수의 이름을 바꾸면 그 변수를 사용하는 모든 함수를 찾아 수정해야 한다.
			> 전역 변수의 값이 잘못된 경우 접근 가능한 모든 함수를 의심해야 한다.
			> 코드 블록 내에 같은 이름의 지역 변수를 선언하면 그 영역에서는 전역 변수를 사용할 수 없다. 
	13.1.4 정적 지역 변수
		- 지역 변수를 사용할 때 static 예약어를 사용하면 정적 지역 변수가 된다. (static variable)
		- 정적 지역 변수 또한 지역 변수이므로 사용 범위가 블록 내로 제한된다.
		- 하지만, 정적 지역 변수는 선언된 함수가 반환되더라도 저장 공간을 계속 유지한다.
			> 전역 변수와 유사하게 프로그램이 실행될 때 메모리에 할당되며 프로그램이 끝날 때 까지 존재한다. 
			> 또한, 0으로 자동 초기화된다. 
			> 즉, 정적 지역 변수는 블록 안에서만 사용할 수 있는 전역 변수와 같다. 
			> 이러한 특징으로 하나의 함수가 여러 번 호출되는 경우 같은 변수를 공유할 수 있다. 
	13.1.5 레지스터 변수
		- 지역 변수에 예약어 register를 사용할 경우 레지스터 변수(register variable)를 선언할 수 있다. 
		- 레지스터 변수는 CPU 안에 있는 저장 공간인 레지스터를 사용한다.
			> 레지스터는 CPU안에 있기 때문에 데이터 처리 속도가 가장 빠른 저장 공간이다.
			> 따라서, 사용 횟수가 많은 경우 실행 시간을 줄일 수 있다.
		- 레지스터 변수는 저장공간이 메모리에 있는 것이 아니라 CPU의 자원을 잠깐 빌리는 것이다.
			> 따라서, 전역 변수는 레지스터로 할당할 수 없다.
			> 또한, 주소 연산자를 써서 포인터를 구할 수 없다.
		- 레지스터 변수로 사용하다 하더라도 컴파일러가 레지스터와 메모리 중 어디에 할당하는 것이 이득인지 판단하여 사용 여부를 결정한다. 
	
*/
