#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "includeTest.h"
#define PI 3.141592
#define DEFINEFUNCTEST printf("매크로명이 적용되었습니다.\n")
#define MUL(a, b) ((a) * (b))


int main(void)
{
	printf("(1)\n");
	testFunction();	//"includeTest.h"에 포함된 함수
	//#include를 통해 사용자 지정 헤더파일을 포함시킨 후 포함시킨 함수 사용
	
	printf("\n(2)\n");
	printf("%.6lf\n", PI);
	DEFINEFUNCTEST;
	//상수와 문장을 매크로명을 통해 사용 
	printf("\n(3)\n");
	printf("3 * 4 = %d\n", MUL(3, 4));
	//매크로 함수를 통한 곱셈값 출력 
	 
	scanf("%d");
	return 0;
}


/*
[19장 전처리와 분할 컴파일]
<19.1 전처리 지시자>
19.1.1 파일을 포함하는 #include
	- 컴파일러 과정은 크게 세 단계로 나눌 수 있다.
		> 전처리 과정 > 컴파일 > 링크
	- 전처리는 전처리기(preprocessor)가 소스코드를 컴파일하기 좋게 다듬는 과정이며 #으로 시작하는 지시자를 처리한다.
	- #include는 지정한 파일의 내용을 읽어와 지시자가 있는 위치에 붙여 놓는 기능을 수행한다. 
	- #include의 사용법은 크게 두 가지로 나뉜다.
		> 파일명을 <>로 묶는 경우 : 꺾쇠괄호(<, >)를 사용하면 복사할 파일을 컴파일러가 설정한 include 디렉터리에서 찾는다.
			- 표준 라이브러리 함수를 사용할 때 필요한 헤더 파일을 다룰 때 주로 사용한다.
			ex) #include<stdio.h>
		> 파일명을 ""로 묶는 경우 : 큰 따옴표를 사용하면 복사할 파일을 소스 파일이 저장된 디렉터리에서 먼저 찾은 후 없는 경우 컴파일러가 설정한 include 디렉터리에서 찾는다.
			- 주로 사용자 지정 헤더 파일을 사용할 때 사용한다.
			ex) #include "student.h"
			- 다른 디렉터리에 있는 파일을 포함할 때는 경로를 포함한 파일명을 사용한다.
				ex) include "c:\user\mydr.h" 
	- #inlcude는 전처리 과정에서 단순히 인클루드한 파일을 복사해서 붙여넣는 기능을 수행한다. 따라서, 모든 텍스트 파일에 사용할 수 있다. 
19.1.2 매크로명을 만드는 #define
	- #define은 매크로명을 정의하는 전처리 지시자이다. 
	- #define 매크로명 치환부분  형태로 사용한다.
		ex) #define PI 3.141592 
	- 매크로명을 정의하여 복잡한 상수나 문장을 의미 있는 단어로 쓸 수 있다. (매크로명은 관례상 대문자로 쓴다.)
	- 매크로명을 사용하는 예시들은 다음과 같다.
		>#define PI 3.141592		- 상수를 매크로명으로 정의
		>#define MSG "passed!"		- 문자열을 매크로명으로 정의
		>#define ERR_PRN printf("범위를 벗어났습니다.\n")	- 문장을 매크로명으로 정의  
	- 매크로의 치환될 부분이 너무 길어 여러 줄에 써야하면 백슬래시로 연결한다.
		ex) #define INTRO "Perfect C Language \
		& Basic Data Structure"
		실제사용 : Perfect C Language & Basic Data Structure
	- 문제가 발생했을 때 매크로명이 어떤 형태로 치환했는지 매번 확인하는 것은 유지보수가 힘들게 만든다. 따라서, 매크로명은 필요한 경우에만 제한적으로 사용해야 한다. 
19.1.3 #define을 사용한 매크로 함수
	- 매크로 함수는 인수에 따라 서로 다른 결과값을 갖도록 치환한다.
	- 매크로 함수는 #define   매크로 함수명(인수)    치환될 부분 형식으로 사용한다.
		ex) #define SUM(a, b) ((a) + (b))
	- 전처리 과정에서 치환될 때 발생할 수 있는 여러 부작용을 해결하기 위해 치환될 부분에 괄호를 써서 정의하고 인수마다 괄호를 친다.
		> 치환될 부분에 괄호를 치는 이유
			- #define MUL(a, b) a*b 로 된 매크로 함수가 있다고 하자.
			- 30 / MUL(2, 5)를 하면 우리는 30 / 10을 원하지만 실제로는 30 / 2 * 5가 되어 결과가 75로 된다.
			- 이처럼 전처리된 후 원하는 순서의 연산이 안될 수 있기 때문에 치환될 부분에 괄호를 친다.
		> 인수마다 괄호를 치는 이유
			- #define MUL(a, b) (a * b)로 된 매크로 함수가 있다고 하자.
			- MUL(2, 2 + 3)을 한다면 우리는 2 * 5를 원하지만 실제로는 2 * 2 + 3이 되어 7이 된다.
			- 이역시 전처리된 후 원하는 순서의 연산이 안될 수 있기 때문에 인수마다 괄호를 친다.
		> 옳은 방법
			- #define MUL(a, b) ((a) * (b))
	- 매크로 함수는 치환된 후 발생할 문제를 예측하기 힘들고 수정도 쉽지 않는다. 하지만, 함수 호출보다 실행 속도가 빠르다는 장점이 있으므로 크기가 작은 함수에서만 사용하자. 
19.1.4 이미 정의된 매크로
19.1.5 매크로 연산자 #과 ##
19.1.6 조건부 컴파일 지시자
19.1.7 #pragma 지시자

<19.2 분할 컴파일>
19.2.1 분할 컴파일 방법
19.2.2 분할 컴파일에서 extern과 static의 용도
19.2.3 헤더 파일의 필요성과 중복 문제 해결 방법 
*/ 	
