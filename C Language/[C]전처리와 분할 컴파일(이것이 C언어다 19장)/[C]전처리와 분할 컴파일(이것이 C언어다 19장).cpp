#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "includeTest.h"
#define PI 3.141592
#define DEFINEFUNCTEST printf("매크로명이 적용되었습니다.\n")
#define MUL(a, b) ((a) * (b))
#define VER 7
#define BOOL

void divisionTestFunc();

int main(void)
{
	printf("(1)\n");
	testFunction();	//"includeTest.h"에 포함된 함수
	//#include를 통해 사용자 지정 헤더파일을 포함시킨 후 포함시킨 함수 사용
	
	printf("\n(2)\n");
	printf("%.6lf\n", PI);
	DEFINEFUNCTEST;
	//상수와 문장을 매크로명을 통해 사용 
	printf("\n(3)\n");
	printf("3 * 4 = %d\n", MUL(3, 4));
	//매크로 함수를 통한 곱셈값 출력 
	printf("\n(4)\n");
	printf("컴파일을 시작한 날짜, 시간 : %s / %s\n", __DATE__, __TIME__);
	printf("현재 파일의 이름 : %s\n", __FILE__);
	printf("이 명령어가 포함된 함수의 이름과 행 번호 : %s %d\n", __FUNCTION__, __LINE__);
	#line 27 "test.c"
	printf("바뀐 파일의 이름 : %s\n", __FILE__);
	// 이미 정의된 매크로명 사용  
	printf("\n(5)\n");
	#if VER<6
		printf("첫 번째 경우\n");
	#elif VER<7
		printf("두 번째 경우\n");
	#else
		printf("세 번째 경우 \n");
	#endif
	#ifdef BOOL
		printf("BOOL이 선언됨\n");
	#else
		#error BOOL이 선언되지 않음!
	#endif
	//조건부 컴파일 지시자 사용
	printf("\n(6)\n");
	divisionTestFunc(); 
	
	 
	scanf("%d");
	return 0;
}


/*
[19장 전처리와 분할 컴파일]
<19.1 전처리 지시자>
19.1.1 파일을 포함하는 #include
	- 컴파일러 과정은 크게 세 단계로 나눌 수 있다.
		> 전처리 과정 > 컴파일 > 링크
	- 전처리는 전처리기(preprocessor)가 소스코드를 컴파일하기 좋게 다듬는 과정이며 #으로 시작하는 지시자를 처리한다.
	- #include는 지정한 파일의 내용을 읽어와 지시자가 있는 위치에 붙여 놓는 기능을 수행한다. 
	- #include의 사용법은 크게 두 가지로 나뉜다.
		> 파일명을 <>로 묶는 경우 : 꺾쇠괄호(<, >)를 사용하면 복사할 파일을 컴파일러가 설정한 include 디렉터리에서 찾는다.
			- 표준 라이브러리 함수를 사용할 때 필요한 헤더 파일을 다룰 때 주로 사용한다.
			ex) #include<stdio.h>
		> 파일명을 ""로 묶는 경우 : 큰 따옴표를 사용하면 복사할 파일을 소스 파일이 저장된 디렉터리에서 먼저 찾은 후 없는 경우 컴파일러가 설정한 include 디렉터리에서 찾는다.
			- 주로 사용자 지정 헤더 파일을 사용할 때 사용한다.
			ex) #include "student.h"
			- 다른 디렉터리에 있는 파일을 포함할 때는 경로를 포함한 파일명을 사용한다.
				ex) include "c:\user\mydr.h" 
	- #inlcude는 전처리 과정에서 단순히 인클루드한 파일을 복사해서 붙여넣는 기능을 수행한다. 따라서, 모든 텍스트 파일에 사용할 수 있다. 
19.1.2 매크로명을 만드는 #define
	- #define은 매크로명을 정의하는 전처리 지시자이다. 
	- #define 매크로명 치환부분  형태로 사용한다.
		ex) #define PI 3.141592 
	- 매크로명을 정의하여 복잡한 상수나 문장을 의미 있는 단어로 쓸 수 있다. (매크로명은 관례상 대문자로 쓴다.)
	- 매크로명을 사용하는 예시들은 다음과 같다.
		>#define PI 3.141592								- 상수를 매크로명으로 정의
		>#define MSG "passed!"								- 문자열을 매크로명으로 정의
		>#define ERR_PRN printf("범위를 벗어났습니다.\n")	- 문장을 매크로명으로 정의  
	- 매크로의 치환될 부분이 너무 길어 여러 줄에 써야하면 백슬래시로 연결한다.
		ex) #define INTRO "Perfect C Language \
		& Basic Data Structure"
		실제사용 : Perfect C Language & Basic Data Structure
	- 문제가 발생했을 때 매크로명이 어떤 형태로 치환했는지 매번 확인하는 것은 유지보수가 힘들게 만든다. 따라서, 매크로명은 필요한 경우에만 제한적으로 사용해야 한다. 
19.1.3 #define을 사용한 매크로 함수
	- 매크로 함수는 인수에 따라 서로 다른 결과값을 갖도록 치환한다.
	- 매크로 함수는 #define   매크로 함수명(인수)    치환될 부분 형식으로 사용한다.
		ex) #define SUM(a, b) ((a) + (b))
	- 전처리 과정에서 치환될 때 발생할 수 있는 여러 부작용을 해결하기 위해 치환될 부분에 괄호를 써서 정의하고 인수마다 괄호를 친다.
		> 치환될 부분에 괄호를 치는 이유
			- #define MUL(a, b) a*b 로 된 매크로 함수가 있다고 하자.
			- 30 / MUL(2, 5)를 하면 우리는 30 / 10을 원하지만 실제로는 30 / 2 * 5가 되어 결과가 75로 된다.
			- 이처럼 전처리된 후 원하는 순서의 연산이 안될 수 있기 때문에 치환될 부분에 괄호를 친다.
		> 인수마다 괄호를 치는 이유
			- #define MUL(a, b) (a * b)로 된 매크로 함수가 있다고 하자.
			- MUL(2, 2 + 3)을 한다면 우리는 2 * 5를 원하지만 실제로는 2 * 2 + 3이 되어 7이 된다.
			- 이역시 전처리된 후 원하는 순서의 연산이 안될 수 있기 때문에 인수마다 괄호를 친다.
		> 옳은 방법
			- #define MUL(a, b) ((a) * (b))
	- 매크로 함수는 치환된 후 발생할 문제를 예측하기 힘들고 수정도 쉽지 않는다. 하지만, 함수 호출보다 실행 속도가 빠르다는 장점이 있으므로 크기가 작은 함수에서만 사용하자. 
19.1.4 이미 정의된 매크로
	- 매크로에는 이미 그 정의가 약속되어 있어 사용자가 임의로 변경할 수 없는 매크로 명이 있다. (여기에 나오는 모든 매크로명은 앞뒤로 _가 2개씩 들어가있다.) 
		1) __FILE__ 	: 전체 디렉터리 경로를 포함한 파일명으로 치환된다. 
		2) __FUNCTION__ : 이 매크로명을 사용한 함수의 이름으로 치환된다. 
		3) __LINE__		: 이 매크로명을 사용한 행 번호로 치환된다. 
		4) __DATE__		: 컴파일을 시작한 날짜로 치환된다. 
		5_ __TIME__ 	: 컴파일을 시작한 시간으로 치환된다.
	- __FILE__, __LINE__은 #line 지시자로 정의(치환값)을 변경할 수 있다.
		>사용법 : #line 시작행번호 파일명(생략가능)
		ex) #line 100 "macro.c"
			> 해당 문장이 12행에 있었다고 하면 12행부터 시작 행 번호가 100이 되므로 22행에 있는 __LINE__값은 110이다.
			> 해당 문장 이후로 __FILE__의 치환 값은 "macro.c"이다.
		> 함수명은 생략이 가능하나 함수명만 쓰는 것은 불가능하다.
			ex) #line 100 (o)	#line "macro.c" (x) 
19.1.5 매크로 연산자 #과 ##
	- 매크로 함수를 만들 때 매크로 연산자를 사용하면 인수를 특별한 방법으로 치환할 수 있다.
	- #은 매크로 함수의 인수를 문자열로 치환한다.
		ex) PRINT_EXPR(x) printf(#x) / PRINT_EXPR(10 + 20)을 하면 인수가 "10 + 20"으로 치환되어 출력된다. (만약 #이 없었으면 30이 출력되었다.)
	- ##은 매크로 함수의 두 인수를 붙여서 치환한다.
		ex) NAME_CAT(x, y) (x ## y) / NAME_CAT(a, 1) = 10;을 하면 a와 1이 a1으로 합쳐지고, a1이라는 변수가 선언되어 있다는 가정 하에 a1 = 10이 된다. 
19.1.6 조건부 컴파일 지시자
	- 조건부 컴파일 지시자를 사용하여 소스코드를 조건에 따라 선택적으로 컴파일하는 조건부 컴파일을 사용할 수 있다.
	- 조건부 컴파일 지시자는 다음이 있다.
		1)#if : '#if 조건식'처럼 사용하며 조건식이 참이면 #if와 #endif 사이의 모든 문장을 컴파일한다. 
		2)#endif : #if문이 끝나는 곳을 나타낸다. (#elif, #else, #ifdef, #ifndef등 조건식이 사용되는 조건부 컴파일 지시자를 모두 포함하여 끝나는 곳을 나타낸다.)
		3)#elif : '#elif 조건식'처럼 사용한다. else if를 줄인 것으로 #if의 조건식이 거짓일 경우 #elif의 조건식을 확인하여 참이면 다음 문장들을 컴파일한다. 
		4)#else : #if, #elif 모두 거짓인 경우 다음 문장들을 컴파일한다. 
		5)#ifdef : '#ifdef 매크로명' 처럼 사용되며 해당 매크로명이 정의되어 있는 경우 다음 문장들을 컴파일한다. (&&, ||등의 연산자를 사용할 때는 #if defined를 사용한다.) 
		6)#ifndef : '#ifndef 매크로명' 처럼 사용되며 해당 매크로명이 정의되어 있지 않은 경우 다음 문장들을 컴파일한다. (&&, ||등의 연산자를 사용할 때는 #if !defined를 사용한다.) 
		7)#error : '#error 문자열' 처럼 사용되며 문자열을 출력하고 컴파일을 중단한다. 
	- 보통 #if(혹은 #ifdef, #ifndef) ~ #elif ~ #else ~ #endif 형식으로 사용된다. 
19.1.7 #pragma 지시자
	- '#pragma 지시명' 형태로 사용하며 컴파일 방법을 세부적으로 제어할 수 있다.
	- 지시명 예시
		> pack(push(생략가능), 크기) : 구조체의 패딩 바이트 크기를 결정한다.
		> warning(disable:경고번호) : 해당 경고번호의 경고 메시지를 표시하지 않음
		> 외에도 많은 지시명이 있다. 

<19.2 분할 컴파일>  - 현재 컴퓨터에서는 프로젝트를 실행할 수 없으므로 차후에 학습한다. 
19.2.1 분할 컴파일 방법
19.2.2 분할 컴파일에서 extern과 static의 용도
19.2.3 헤더 파일의 필요성과 중복 문제 해결 방법 
*/ 	
