#include<stdio.h>

void print_ary(int *pa);
void print_ary_n(int *pa, int size);
void input_ary(int *pa, int size);

int main(void)
{
	int ary[5] = {0, 1, 2, 3, 4};
	int second[5] = {5, 6, 7, 8, 9};
	int third[8] = {10, 11, 12, 13, 14, 15, 16, 17};
	int *pa;
	int *pb;
	
	printf("(1)\n");
	printf("배열명의 값 : %u\n", ary);
	printf("첫 번째 배열 요소의 주소 값 : %u\n", &ary[0]);
	printf("배열명이 가리키는 값 : %d\n", *ary);
	printf("첫 번째 배열 요소의 값 : %d\n", ary[0]);
	//배열명의 값  = 첫 번째 배열 요소의 주소 값임을 증명한다.
	
	printf("\n(2)\n"); 
	printf("ary의 값 : ");
	for(int i=0; i<5; i++)
	{
		printf("%d ", *(ary + i));
	}
	printf("\n");
	//배열명은 주소로 변환되고, 주소 덧셈 연산을 통해 다른 배열 요소에 접근할 수 있다. 
	
	printf("\n(3)\n");
	pa = ary;
	printf("배열명을 이용한 배열 값 : %d %d %d %d %d\n", ary[0], ary[1], ary[2], ary[3], ary[4]);
	printf("포인터를 이용한 배열 값 : %d %d %d %d %d\n", pa[0], pa[1], pa[2], pa[3], pa[4]);
	
	//포인터에 배열명을 저장할 경우 포인터를 배열명처럼 사용할 수 있음을 보여준다. 
	
	printf("\n(4)\n");
	pa = ary;
	printf("배열명의 sizeof 값 : %d\n", sizeof(ary));
	printf("포인터의 sizeof 값 : %d\n", sizeof(pa));
	//배열명과 포인터의 sizeof 반환값은 다르다. 배열명은 배열의 크기를, 포인터는 포인터변수 자체의 크기를 반환한다.
	
	printf("\n(5)\n");
	pa = ary;
	/*printf("배열명에 후위연산자를 사용한 경우 값 : ");
	for(int i=0; i<5; i++)
	{
		printf("%d ", *(ary++));
	} */
	printf("\n");
	printf("포인터에 후위연산자를 사용한 경우 값 : ");
	for(int i=0; i<5; i++)
	{
		printf("%d ", *(pa++));
	}
	printf("\n");
	//배열명은 상수이기 때문에 주석처리된 구문 자체가 에러처리가 된다. 하지만, 포인터는 주소값을 변경할 수 있다. 
	
	printf("\n(6)\n");
	pa = ary; 
	pb = second;
	printf("pa값 : %d / pb값 : %d\n", pa, pb);
	printf("pb - pa : %d\n", pb - pa);
	//주소끼리의 뺄셈은 주소값의 차 / 자료형 임을 나타낸다. 
	
	printf("\n(7)\n");
	print_ary(ary);
	//10.2.1의 배열의 값을 출력하는 함수
	
	printf("\n(8)\n");
	print_ary_n(third, 8);
	//10.2.2의 배열 요소의 개수가 다른 배열도 출력하는 함수
	
	printf("\n(9)\n");
	input_ary(second, 5);
	print_ary_n(second, 5);
	//10.2.3의 배열에 값을 입력하는 함수 
	
	
	scanf("%d");
	
	return 0;
}

void print_ary(int *pa)
{
	printf("배열의 값 : "); 
	for(int i=0; i<5; i++)
	{
		printf("%d ", pa[i]);
	}
	printf("\n");
}

void print_ary_n(int *pa, int size)
{
	printf("배열의 값 : ");
	for(int i=0; i<size; i++)
	{
		printf("%d ", pa[i]);
	}
	printf("\n");
}

void input_ary(int *pa, int size)
{
	for(int i=0; i<size; i++)
	{
		printf("입력할 %d번째 값 : ", i+1);
		scanf("%d", pa+i);
	}
	printf("\n");
}

/*
[10장 배열과 포인터] 
=10.1 배열과 포인터의 관계=
	10.1.1 배열명의 정체
		- 배열명은 컴파일 과정에서 첫 번째 배열 요소의 주소로 바뀐다. 즉, 배열명은 첫 번째 요소의 주소와 같다. 
	10.1.2 배열명으로 배열 요소 사용하기 
		- 주소는 정수처럼 보이나 자료형에 대한 정보를 가진 특별한 값이다. 따라서, 정해진 연산만 가능하다.
		- 주소 덧셈 연산은 다음과 같이 수행된다.
			> 주소 + 정수 = 주소 + (정수 * 주소를 구한 변수의 크기)
			> ex) int a[5], a의 주소값이 100이라고 할 때 a + 1 = 104 / a + 2 = 108 (int의 크기가 4이므로 정수에 4가 곱해져서 연산이 된다.)
		- 배열에서 사용하는 대괄호는 연산자이다. 배열명[정수] 는 사실 *(배열명 + 정수)를 수행하는 연산자이다. 
			> ary[1] ==  *(ary + 1)
	10.1.3 배열명 역할을 하는 포인터
		- 배열명은 주소를 의미하므로 포인터에 저장할 수 있다.
		- 포인터에 배열명을 저장하면 포인터를 배열명처럼 사용할 수 있다.
			> ex) pa는 포인터, ary는 정수형 배열이라고 했을 때 pa = ary로 포인터에 배열을 저장한 경우 pa[3] == ary[3] 이다. 
	10.1.4 배열명과 포인터의 차이
		- sizeof 연산을 사용했을 때 배열명은 배열 전체의 크기를 반환하지만 포인터는 포인터 자체의 크기만 반환한다.
		- 포인터는 값을 바꿀 수 있으나 배열명은 상수이기 때문에 불가능하다.
			> 따라서, 포인터는 다음과 같은 연산이 가능하다.
				>> pa = pa + 1 / pa++ 
	10.1.5 포인터의 뺄셈과 관계 연산
		- 주소 뺄셈 연산은 다음과 같이 수행된다.
			> 주소 - 주소 (포인터 - 포인터) = 값의 차 / 가리키는 자료형의 크기
				ex) pa의 주소값이 108, pb의 주소값이 120이고 정수형인 경우 pb - pa = 12/4 = 3이다.
		- 주소간 관계 연산은 정수의 연산처럼 주소값의 크기 차이를 비교해 연산한다. 
		
=10.2 배열을 처리하는 함수=
	10.2.1 배열의 값을 출력하는 함수
		- 배열의 값을 사용하는 반복 작업이 있다면, 그 기능을 함수로 만들어 호출하는 것이 좋다.
		- 함수를 호출할 때 배열명을 주고, 함수의 매개변수로 포인터를 선언한 뒤 함수 안에서 포인터를 배열명처럼 사용하면 된다.
	10.2.2 배열 요소의 개수가 다른 배열도 출력하는 함수
		- 함수의 매개변수에 배열 요소 갯수도 추가하여 해결한다.
	10.2.3 배열에 값을 입력하는 함수
		- 함수를 통해 값을 입력받는 경우 매개변수로 사용한 포인터를 사용하여 입력받으면 된다. 
*/
