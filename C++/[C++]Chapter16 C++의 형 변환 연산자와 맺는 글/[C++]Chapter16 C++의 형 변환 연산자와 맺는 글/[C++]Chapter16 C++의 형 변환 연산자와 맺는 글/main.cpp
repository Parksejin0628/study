#include<iostream>

using std::cout;
using std::cin;
using std::endl;

int main(void)
{


	return 0;
}

/*
[Chapter 16 C++의 형 변환 연산자]
<16.1. C++에서의 형 변환 연산>
1. C 스타일의 형 변환 연산자는 프로그래머의 의도 파악이 힘들고 형 변환의 범위가 너무 크기에 좋은 형 변환이 아니다.
	- C++에서는 새로운 형 변환 연산자와 규칙을 제공한다.
2. C++의 형 변환 (T : 변환하고자 하는 자료형의 포인터 혹은 참조형 / exper : 변환의 대상)
	- dynamic_cast<T>(expr)
		>용도 : 유도클래스 >> 기초클래스 변환 / 추상클래스의 경우만 기초클래스 >> 유도클래스 변환
		>특징 : 변환 시도 중 문제가 발생하면 특정 정보 반환 / 안정적인 형 변환
	- static_cast<T>(expr)
		>용도 : 기초클래스 >> 유도클래스 변환 / 기본 자료형 형 변환
		>특징 : dynamic_cast보다 더 많은 형 변환 허용 / 안정성이 떨어진다.
	- const_cast<T>(expr)
		>용도 : const의 성향 제거
		>특징 : const함수가 아니어도 const 변수를 사용할 수 있게 해줌 / const 선언의 가치를 떨어뜨리기에 제한적으로 사용
	- reinterpret_cast<T>(expr)
		>용도 : 포인터와 관련된 모든 유형 형 변환
		>특징 : 포인터 주소를 정수로 바꾸는 등 용도는 다양하나 사용하려면 좀 더 숙달할 필요가 있다.
*/

/*
[Chapter16 C++의 형 변환 연산자와 맺는 글]
<16.1. C++에서의 형 변환 연산>
1. C 스타일의 형 변환 연산자는 C언어와의 호환성을 위해서 존재할 뿐, C++ 에서는 새로운 형 변환 연산자와 규칙을 제공하고 있다. 이는 여러 단점 때문이다.
	- 특정 형변환에 대하여 프로그래머의 실수인지, 의도인지 제대로 파악하기 힘들다
	- 일반적이지 않은 말도 안되는 형 변환까지 허용한다.
2. dynamic_cast
	1) 형태 : dynamic_cast<T>(expr) / T : 변환하고자 하는 자료형의 포인터 혹은 참조형 / expr : 변환의 대상
		ex) SimpleClass *other = dynamic_cast<*SimpleClass>(obj)
	2) 용도
		- 유도클래스(의 포인터 및 참조형 데이터) >> 기초클래스(의 포인터 및 참조형 데이터)로 변환한다.
		- 기초클래스에 가상함수가 하나 이상 존재할 경우, 기초 클래스(의 포인터 및 참조형 데이터) >> 유도 클래스(의 포인터 및 참조형 데이터)로 변환을 허용한다.
	3) 특징
		- 상속관계에 있는 유도 클래스의 포인터 및 참조형 데이터를 기초 클래스의 포인터 및 참조형 데이터로 형 변환하겠다는 의도를 담는 문장이다.
		- 후에 나올 static_cast와의 차이점으로 변환이 문제될 경우 특정 정보를 반환한다.
			> 포인터로 변환 시도 중 문제가 발생할 경우 NULL 포인터 반환
			> 참조형으로 변환 시도 중 문제가 발생할 경우 bad_cast 예외 반환 (예외처리)
				>> 이는 참조형을 대상으로 dynamic_cast 연산을 진행할 때 반드시 이에 대한 예외처리를 해야 한다는 의미이다.
		- 컴파일 시간이 아닌 실행 시간에 안전성을 검사하도록 컴파일러가 바이너리 코드를 생성한다.
			> 이는 static_cast와는 다르게 안정적인 형 변환을 보장한다는 의미이다.
3. static_cast
	1) 형태 : static_cast<T>(expr) / T : 변환하고자 하는 자료형의 포인터 혹은 참조형, 기본 자료형일 경우 그냥 자료형 / expr : 변환의 대상
				ex) SimpleClass *other = static_cast<&SimpleClass>(obj)
				ex) int num = static_cast<int>(pi)
	2) 용도
		- 기초클래스(의 포인터 및 자료형 데이터) >> 유도클래스(의 포인터 및 참조형 데이터)
		- 기본 자료형의 형변환
	3) 특징
		- dynamic_cast 보다 더 많은 형 변환을 허용하지만 그에 따른 책임도 프로그래머가 져야 한다.
		- 정말 책임질 수 있는 경우에만 제한적으로 사용해야한다.
		- C언어의 말도 안되는 형 변환보다는 범위가 작다.
4. const_cast
	1) 형태 : const_cast<T>(expr) / T : 변환하고자 하는 자료형의 포인터 혹은 참조형 / expr : 변환의 대상
	2) 용도 : const의 성향을 제거하려는 목적
	3) 특징
		- const 선언의 가치를 떨어뜨릴 수 있기 때문에 제한적으로 사용해야 한다.
		- const 함수가 아니어도 const 변수를 사용할 수 있게 만들 때 사용한다.
			ex) const char * name = "Lee Sung Ju";
				ShowString(const_cast<char*>(name));
5. reinterpret_cast
	1) 형태 : reinterpret_cast<T>(expr) / T : 변환하고자 하는 자료형의 포인터 혹은 참조형 / expr : 변환의 대상
	2) 용도 : 포인터와 관련 있는 모든 유형의 형 변환
	3) 특징
		- 상속 관계가 아닌 전혀 상관없는 클래스도 형 변환이 가능하게 한다.
		- 포인터 주소를 정수로 바꾸는 등 용도는 다양하다.
		- 현재로써는 사용의 필요성을 못느끼지만, 떄가 되면 사용하리라 생각한다.
*/
