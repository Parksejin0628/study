#include<iostream>

using std::cin;
using std::cout;
using std::endl;

struct Point
{
	int xpos;
	int ypos;
	
	void MovePos(int addX, int addY)
	{
		xpos += addX;
		ypos += addY;
	}
	
	void ShowPosition()
	{
		cout<<"["<<xpos<<" ,"<<ypos<<"]"<<endl;
	}
	
	void AddPoint(const Point &otherPoint)
	{
		xpos += otherPoint.xpos;
		ypos += otherPoint.ypos;
	}
};

void que3_1();

int main(void) 
{
	int num;
	que3_1();
	
	cin>>num;
	
	return 0;
}

void que3_1()
{
	/*문제 : 2차원 평면상에서의 좌표를 표현할 수 있는 구조체를 정의한 뒤 해당 구조체를 기반으로 함수를 정의한다.
	 		 단, 구조체 안에 함수를 정의하여 다음의 형태로 구성해야 한다. (구조체 함수 정의하기 문제)
	*/
	Point pos1 = {12, 4};
	Point pos2 = {20, 30};
	
	pos1.MovePos(-7, 10);
	pos1.ShowPosition();	//[5, 14] 출력 
	
	pos1.AddPoint(pos2);	//[25, 44] 출력  
	pos1.ShowPosition();
	 
	return;
}

/*
[Chapter 03 클래스의 기본]
// 배우는 내용이 많은 것에 비해 실습할 문제는 적으므로 따로 하나의 예시를 만들면 좋을 듯 하다. 
3.1. C++에서의 구조체
 1) C와 비교되는 C++에서의 구조체 변수 선언  
  - C++는 typedef 선언을 하지 않아도 구조체 변수를 선언할 때 struct를 붙이지 않아도 된다. (정의가 아닌 선언이다.)
  	ex) C에서의 구조체 변수 선언 : struct Car basicCar 
  		C++에서의 구조체 변수 선언 : Car BasicCar (typedef 별도 사용 X)
 2) 구조체 안에 함수 삽입
  - 데이터를 묶은 구조체가 생긴다면 해당 구조체만을 위한 함수가 필요할 수 있다. (종속적인 함수)
  - 기존 C언어에서는 전역함수의 형태로 만들어야 했기 때문에 구조체에 종속되었다는 느낌도 잘 들지 않고 다른 데이터에서 함수에 접근할 가능성도 있었다.
  - C++에서는 구조체 안에 함수를 삽입할 수 있어서 구조체에 종속된 함수를 만들 수 있다.
  - 구조체안에 함수를 종속하면 별도로 데이터를 전달하지 않아도 구조체 안에 있는 데이터에 직접접근할 수 있다.
  	ex) C언어에서 전역함수로 선언한 경우 : void Fun1(struct Car basicCar);
	  	C++언어에서 종속된 함수로 선언한 경우 : void Fun1();
		즉, 데이터를 전달하지 않아도 구조체의 데이터를 사용할 수 있다.
  - 구조체 변수를 여러 개 만들더라도 함수가 여러개 생성되는 것이 아닌 하나의 함수를 구조체들이 공유하는 형태로 한다.
  - 구조체에 함수가 있다 해도 초기화의 대상은 변수이기 때문에 초기화 방법은 달라지지 않는다. 
 3) 구조체 안에 enum 상수 선언
  - 해당 구조체 안에서만 필요한 상수들이 존재할 수 있다. 기존 C언어에서는 define하거나 enum으로 전역범위에서 열거했어야 했다.
  - C++에서는 구조체 안에 열거형 enum을 선언해서 구조체 내에서만 유효한 상수를 정의할 수 있다.
 4) 또다른 enum 상수 선언, 이름공간 이용
  - 구조체 안에 열거형을 넣는 방법 외에도 이름 공간을 이용해 상수가 사용되는 영역을 명시하는 것도 또 다른 방법이다.
  	ex) namespace CAR_CONST { enum { ID_LEN = 20, ...}; } / struct CAR{ char gameID[CAR_CONST::ID_LEN]; ... } 
	    이처럼 이름 공간에 상수가 사용되는 영역을 명시한 후 구조체 안에서 사용하면 된다.
  - 이렇게 이름 공간을 사용함으로써 구조체 안에 enum이 있는 것 보다 가독성이 좋아지며 몇몇 구조체들 사이에서만 사용하는 상수를 선언할 때도 유용하다.
 5) 구조체 안에 삽입한 함수를 외부에서 정의하기
  - 프로그램을 분석할 때는 흐름, 골격 위주로 분석하는 경우가 많다.
  - 따라서, 구조체를 보는 순간 구조체 안에 선언된 변수, 정의되어 있는 함수의 정보가 한 눈에 들어와야 한다. 그러나, 구조체 안에 함수를 정의하면 한 눈에 함수 정보가 들어오지 않는다.
  - 이러한 문제를 해결하기 위해 구조체 안에만 함수 원형을 선언하고, 정의를 외부에서 할 수 있다.
  - 구조체 외부에서 구조체::함수명() { ... } 와 같은 형태를 통해 구조체 외부에서 함수를 정의할 수 있다.
  	ex) struct Car{... void ShowCarState();...} / void Car::ShowCarState() { ... } 이처럼 구조체 밖에서 정의할 수 있다.
  - 구조체 안에 함수가 정의되어 있으면 함수를 인라인으로 처리한다는 의미이다. 그런데, 구조체 밖으로 빼내면 이러한 의미가 사라진다.  따라서, 키워드 inline을 이용해 인라인 처리를 명시적으로 지시할 필요가 있다.
  	ex) inline void Car::ShowCarState() { ... } 
 6) 사실 구조체는 클래스의 일종
  - C++에서 구조체는 클래스의 일종으로 간주된다.
  - 때문에, 구조체 안에 함수를 정의할 수 있었다.
 
3.2. 클래스(Class)와 객체(Object)
 1) 클래스란?
  - 내가 여태까지 익힌 구조체에서 struct 대신 class를 쓰면 클래스가 된다.
  	ex) struct Car -> class Car
 2) 구조체와 비교되는 클래스의 특징
  - 함수 선언과 동시에 초기화가 불가능하다?
  - 별도로 접근과 관련한 선언을 하지 않으면, 클래스 내에 선언된 변수와 함수는 클래스 밖에서 접근하는 것을 허용하지 않는다.
  	> 즉, 여태까지 구조체에서 했던 것 처럼 메인함수에서 클래스의 변수와 함수에 접근하는 것은 일반적으로 불가능하다.
  - 따라서, 클래스는 정의를 하는 과정에서 각각의 변수와 함수의 접근 허용범위를 별도로 선언해야한다. 이것이 구조체와 클래스의 유일한 차이점이다.
  - 이러한 접근 허용범위는 접근제어 지시자를 통해 선언한다. 
 3) 접근제어 지시자(접근제어 레이블)
  - C 
 
 


*/
