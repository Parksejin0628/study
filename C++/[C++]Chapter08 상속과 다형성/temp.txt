#include<iostream>
using std::cin;
using std::cout;
using std::endl;

int main(void)
{
	
	
	return 0;
}

/*
[Chapter08 상속과 다형성]
<8.1. 객체 포인터의 참조관계> 
1. 유도클래스도 참조가 가능한 객체 포인터 변수
 1) 클래스를 기반으로도 포인터 변수를 선언할 수 있다.
 	ex) Person * ptr;
	 	ptr = new Person();
 2) 그런데, 이러한 포인터 변수는 해당 객체 뿐만 아니라 그 객체의 클래스를 상속하는 유도 클래스의 객체도 가리킬 수 있다.
 	> 책의 표현을 인용하자면 'C++에서, AAA형 포인터 변수는 AAA 객체 또는 AAA를 직접 혹은 간접적으로 상속하는 모든 객체를 가리킬 수 있다(객체의 주소 값을 저장할 수 있다).'
 	> 이 표현해서 '간접적으로 상속'은 AAA를 상속하는 클래스를 상속한다는 의미이다. 
	ex1) Person * ptr;
		 ptr = new Student(); (Student는 Person을 상속하는 유도클래스이다.)
	ex2) Person * ptr2;
		 ptr2 = new PartTimeStudent(); (PartTimeStudent는 Student를 상속하는 유도클래스이다. Student는 Person을 상속하므로 이 문장이 가능하다.)
 3) 이런 표현이 가능한 이유를 알아보기 위해 위 Person을 예로 들어보자.
   > Student, PartTimeStudent는 모두 Person과 IS-A 관계이다.
   > 즉, Student, PartTimeStudent는 모두 Person이다.
   > 따라서, 논리적으로 Person 포인터 변수가 Student, PartTimeStudent를 가리킬 수 있는 것이다.
 4) 해당 표현을 통해서 우리는 좋은 프로그램의 조건 중 하나인 유연성과 확장성을 확보할 수 있다.
 	> 예를 들어, 위 Person을 사용하는 프로그램에서 Person을 대상으로 한 컨트롤 클래스가 있다고 하자.
	> 만약 Person을 상속하는 Teacher이 추가됐다고 하면 우리는 Teacher을 위해 컨트롤 클래스를 수정할 필요가 있었을 것이다.
	> 하지만, 포인터로 유도클래스도 참조가 가능하게 함으로써, Teacher을 가리키는 변수를 추가할 필요 없이 Person 포인터 변수가 Teacher을 가리키게 하여 수정을 최소화할 수 있다.
	> 결국, Person을 직접 혹은 간접적으로 상속하는 클래스가 추가되었을 때, 컨트롤클래스의 변화가 필요 없어지는 것이다.
	> 이는, 유연성과 확장성의 큰 기여를 한다.
2. 함수 오버라이딩
 1) 함수 오버라이딩(function overriding)
 	> 기초클래스에서 상속받는 함수를 유도클래스에서 동일한 이름과 형태로 '재정의'하는 것이다. (오버라이딩은 무시하다는 의미로 기존 함수를 무시하고 새로 정의한다는 의미를 담고있다.) 
	> 유도클래스에서 유도클래스만 가지는 기능을 다시 정의할 때 사용된다.
	> 해당 유도클래스에서 해당 이름의 함수를 호출할 경우 기존 기초클래스에 있던 함수가 아닌 유도클래스에서 재정의된 함수가 호출된다. 
	> 기초클래스에 오버라이딩한 함수를 호출하는 함수가 있을 경우 이 함수는 기초클래스의 함수를 호출하게되므로 유도클래스에있는 함수를 호출하게 하기 위해서는 역시 유도클래스에서 오버라이딩 해야한다. 
	
<8.2. 가상함수>
1. 포인터 연산에 대한 컴파일러의 판단
 1) 앞에서 확인했듯 클래스형 포인터 변수는 유도클래스까지 가리킬 수 있다.
 	ex) Person *ptr / ptr = new Student();
 2) 하지만 컴파일러는 포인터 연산의 가능성을 판단할 때 자료형을 기준으로 한다. 즉, 기초클래스 포인터로 유도클래스를 가리키는 것은 가능하지만 유도클래스의 멤버는 사용할 수 없는 것이다. 
 	> Base * bptr 포인터 변수가 있다고 하면 bptr은 Base외에도 유도클래스인 Derived를 가리킬 수 있다.
	> 하지만, bptr의 자료형은 Base이므로 Base의 멤버만 호출할 수 있다.
	> 다시말해, Derived의 멤버함수인 DerivedFunc()는 호출할 수 없다.
 3) 이러한 특징때문에 유도클래스에 기초클래스를 대입하는 것도 제한이 된다.
 	> 즉, Base 포인터 변수가 Derived를 가리키더라도 Derived 포인터 변수에 대입연산은 불가능하다. Base 포인터 변수가 Base를 가리킬지 Derived를 가리킬지는 모르기 때문이다. 
	 	ex) Base *bptr = new Derived(); / Derived *dptr = bptr (x)
	> 또한, 기초클래스 포인터 변수에 유도클래스를 대입하는 것은 가능하다. 이는 기초클래스가 유도클래스를 가리키는 것까지 허용하기 때문이다. 
		ex) Derived *dptr = new Derived(); / Base *bptr = dptr (o)
2. 자료형을 따르는 함수 호출
 1) 앞에서 살펴본 컴파일러 판단의 특징때문에 클래스 포인터 변수의 멤버 호출은 자료형을 따라간다.
 2) 이는, 오버라이딩도 해당이 된다.
 	> 아무리 유도클래스를 가리키고, 오버라이딩이 존재한다고 해도 자료형의 함수를 호출하게 되는 것이다.
	 	ex) First * fptr = new Third / MyFunc()  결과 : FristFunc (함수 오버라이딩이 존재하지만 자료형을 따라 First에 있는 멤버함수 호출) 
			Third * tptr = new Third / MyFunc() 결과 : ThirdFunc (함수 오버라이딩으로 Third에 있는 멤버함수 호출) 
 3) 이러한 특징은 상속의 목적인 확장성과 유연성을 해칠 수 있게 된다.
 	> 가리키는 객체에 따라 원하는 다른 함수를 호출해야 유연성과 확장성이 확보되지만, 자료형만 따르기 때문이다.
	> 이는 가상함수 개념의 등장배경이 되었다. 
3. 가상함수(virtual Function)
4. 순수 가상함수, 추상 클래스(Pure Virtual Function, Abstract Class)
5. 다형성(Polymorphism)

<8.3. 가상 소멸자와 참조자의 참조 가능성>
1. 가상 소멸자
2. 참조자의 참조 가능성  


*/