#include<iostream>
#include"Point.h"

using std::cout;
using std::cin;
using std::endl;

void que1();
void que2();
void que3();

int main(void)
{
	Point pos(2, 4);
	Point cpy(1, 3);

	que1();
	que2();
	que3();

	cpy = 3 + pos;
	cout << "교환법칙 성립 시험";
	cpy.printPos();

	return 0;
}

void que1()
{
	//문제1,2,3 동시풀이
	/*
	<문제1>
	Point 클래스에 대해서 다음 조건을 만족하는 형태로 - 연산자를 오버로딩 해보자.
		> 전역함수 기반으로 오버로딩
		> 멤버 별 - 연산의 결과를 담은 Point 객체 변환
	<문제2>
	Point 클래스에 대해서 다음 조건을 만족하는 형태로 +=연산자와 -=연산자를 오버로딩 해보자.
		> 멤버함수 기반으로 오버로딩
		> 연산 'pos1 += pos2'의 결과로 pos1의 멤버변수 값이 pos2의 멤버변수 값만큼 멤버 별 증가
		> 연산 'pso1 -= pos2'의 결과로 pos1의 멤버변수 값이 pos2의 멤버변수 값만큼 멤버 별 감소
		> 연산의 결과로 값이 증가 및 감소한 pos1의 객체를 반환하도록 (이왕이면 참조형으로 반환하도록) 연산자 오버로딩
	<문제3>
	Point 클래스에 대해서 다음 조건을 만족하는 형태로 == 연산자와 != 연산자를 오버로딩 해보자.
		> 둘 다 전역함수의 형태로 오버로딩
		> 연산 'pos1 == pos2'의 결과로 모든 멤버의 값이 같다면 true, 그렇지 않다면 false 반환
		> 연산 'pos1 != pos2'의 결과로 모든 멤버의 값이 같다면 false, 그렇지 않다면 true 반환
		> 연산자 == 를 먼저 오버로딩 한 다음에, 이를 이용하는 형태로 != 연산자를 오버로딩
	*/
	Point pos1(2, 5);
	Point pos2(1, 3);
	Point pos3 = pos1 - pos2;
	bool result;

	cout << "-연산 결과 : ";
	pos3.printPos();

	pos3 = pos1 += pos2;
	cout << "+=연산 결과 : ";
	pos3.printPos();

	pos3 = pos1 -= pos2;
	cout << "-=연산 결과 : ";
	pos3.printPos();

	result = pos1 == pos2;
	cout << "==연산 결과 : "<<result<<endl;

	result = pos1 != pos2;
	cout << "!=연산 결과 : " << result << endl;

}

void que2()
{
	//문제 1, 2 동시 풀이
	/*
	<문제1 : 멤버함수의 형태로 오버로딩>
	 - 부호 연산자로서 -는 단항 연산자이다. 이 연산자는 피연산자의 부호를 반전시킨 결과를 반환한다.
	   Point 클래스를 대상으로 - 연산자를 오버로딩 해 보자. 다음 문장이 실행되면
		> Point pos2 = -pos1;
	   pos2의 멤버변수는 pos1의 멤버변수 갑소가 다른 부호의 값으로 초기화되도록 오버로딩 해보자.
	<문제2 : 전역함수의 형태로 오버로딩>
	 - ~연산자는 단항 연산자로서 비트단위 not의 의미를 갖는다. 즉, ~연산자는 비트단위로 1은 0으로, 0은 1로 바꾼다. 
	   이에 우리는 Point 객체를 대상으로 다음과 같이 연산이 가능하도록 ~연산자를 오버로딩 하고자 한다.
	    > Point pos2 = ~pos1;
	   위의 ~ 연산의 결과로 반환된 객체의 xpos 멤버에는 pos1의 ypos 값이, 반환된 객체의 ypos 멤버에는 pos1의 xpos 값이 저장되어야 한다.
	*/
	Point pos1(2, 5);
	Point pos2 = -pos1;

	cout << "-단항 연산자 결과 : ";
	pos2.printPos();

	pos2 = ~pos2;
	cout << "~단항 연산자 결과 : ";
	pos2.printPos();

	pos2 = -(-pos2);
	cout << "+ 단항 연산자 2번 결과";
	pos2.printPos();
	//?? 왜 이 과정은 원하는 결과가 나오지 않는 것일까?
	endl(cout);
	// 이 왜 가능

}

void que3()
{
	/*
	<문제 : 입력을 위한 >> 연산자의 오버로딩>
	 - 아래의 함수가 데이터의 입력과 출력이 가능하도록 연산자를 오버로딩해보자
	*/
	Point pos1;
	cout << "x, y 좌표 순으로 입력: ";
	cin >> pos1;
	cout << pos1;

	Point pos2;
	cout << "x, y 좌표 순으로 입력: ";
	cin >> pos2;
	cout << pos2;



	return;
}

/*
[Chapter10 연산자 오버로딩1]
<10.1. 연산자 오버로딩의 이해와 유형>
1. 연산자 오버로딩
 1) 연산자 오버로딩은 'operator' 키워드와 '연산자'를 묶어 함수의 이름을 정의하면 객체에서도 연산자를 이용한 함수의 호출이 가능하게 해준다.
	> 사용방법 : operator+ 와 같이 operator와 연산자로 구성된 함수를 정의해야 한다.
		ex) Point operator+(const Point &ref) { Point pos(xpos + ref.xpos, ypos + ref.ypos);  return pos} 와 같은 함수가 있을 때 Point 객체인 pos1, pos2도 pos1 + pos2연산이 가능하다.
	> 원리 : 기본 자료형(int, double 등)이 아닌 객체에서 연산자를 사용한다고 가정하자.
			pos1+pos2 라는 문장이 있다면 컴파일러는 각각 + -> .operator+ 와 pos2 -> (pos2) 로 변환하여 pos1+pos2 -> pos1.operator+(pos2)로 변환시키는 것이다.
	> -, *, 등 다른 연산자도 operator-, operator* 함수가 있다면 객체끼리 연산이 가능해진다.
 2) 연산자 오버로딩이라 불리는 이유는 같은 연산자를 사용해도 피연산자가 기본자료형이냐 객체이냐에 따라 결과가 달라지기 때문이다.
2. 연산자 오버로딩의 두 가지 방법
 1) 멤버함수에 의한 연산자 오버로딩
    > 컴파일러가 해석하는 방법 : pos1+pos2 -> pos1.operator+(pos2)
	> 방법 : 멤버함수 자리에 연산자 함수를 정의하면 된다.
 2) 전역함수에 의한 연산자 오버로딩
	> 컴파일러가 해석하는 방법 : pos1+pos2 -> operator+(pos1, pos2)
	> 방법 : 전역함수 자리에 연산자 함수를 정의한다. 단, 객체의 멤버에 접근할 수 있도록 해당 함수는 객체 내에서 friend 선언을 해두는 것이 좋다.
		ex) Point operator+(...)함수가 있을 경우 객체 내에서 friend Point operator+(...)를 선언해두어 전역함수에서도 멤버에 접근을 할 수 있게 해둔다.
 3) 우선순위 : 전역함수 기반과 멤버함수 기반으로 동시에 오버로딩 되어있을 경우 멤버함수 기반으로 오버로딩된 함수가 더 우선순위를 갖고 호출된다.
3. 오버로딩이 불가능한 연산자
 > . / .* / :: / ?: / sizeof / typeid / static_cast / dynamic_cast / cosnt_cast / reinterpret_cast
4. 연산자 오버로딩의 주의사항
 1) 연산자 오버로딩 함수도 const로 선언하는 것이 좋다. 보통 피연산자의 값은 변경하지 않기 때문이다.
 2) 본래 의도를 벗어난 형태의 연산자 오버로딩은 좋지 않다.
	ex) +연산인데 피연산자를 곱하는 경우 혼란을 가져올 수 있다.
 3) 연산자의 우선수위와 결합성은 바뀌지 않는다.
	> 즉, + 보다 *가 먼저 연산이 된다.
 4) 연산자 함수에는 매개변수의 디폴트 값을 설정할 수 없다.
 5) 기본 자료형의 연산자는 간섭할 수 없다.
 <10.2. 단항 연산자의 오버로딩>
 1. 단항 연산자 정의 방법
  1) 멤버함수 형태 : operator++()
    > 단항 연산자는 피연산자가 하나이므로 멤버함수 형태일 경우 매개변수가 없다.
  2) 전역함수 형태 : oeprator++(Point &ref)
    > 단항 연산자는 피연산자가 하나이므로 전역함수 형태일 경우 매개변수가 하나이다.
 2. 전위증가/감소 형태의 단항연산자 정의 방법
  1) 형태 : Point.cpp에 있는 Point Point::operator++() 함수를 확인하면 된다.
  2) *this의 의미 : ++연산자는 피연산자의 값이 변화하기에 자기 자신의 참조값을 반환한다는 의미이다.
 3. 후위증가/감소 형태의 단항연산자 정의 방법
  1) 형태 : Point.cpp에 있는 const Point& Point::operator++(int) 함수를 확인하면 된다.
	> 후위 연산의 경우 전위 연산과의 구별을 위해 매개변수에 int형을 추가한다.(실제로 사용은 하지 않는 형식상 매개변수이다.)
  2) const Point& 반환형인 이유
	> 후위 연산의 경우 다른 연산이 모두 끝난 뒤 증가/감소를 진행해야 한다.
	> 기존 값을 가지고 있는 객체를 const 형태로 임시생성한다. 반환한 객체는 const형태이므로 객체 멤버변수 값에 영향을 주지 않고 연산을 진행할 수 있게 된다.
<10.3. 교환법칙 문제의 해결>
 1. 자료형이 다른 두 피연산자를 대상으로 하는 연산
  1) 연산자 오버로딩을 이용할 경우 자료형이 다르더라도 연산을 진행할 수 있게 만들 수 있다.
	ex) 객체인 Point와 int형인 정수의 연산 : cpy = pos * 3;
  2) 연산자 오버로딩을 사용하면 이미 생성된 객체에 대입연산자를 사용하여 멤버 대 멤버 복사를 진행할 수 있다.
 2. 교환법칙 문제 해결하기
  1) 교환법칙을 성립시키기 위해서는 객체가 아닌 자료형도 연산자 오버로딩을 시켜야 한다.
	> 따라서, 전역함수의 형태로 매개변수를 여러 개 받아 해결할 수 있다.
	> 이에 따른 내용은 Point.cpp의 Point operator+(int num, const Point &pos)를 통해 확인할 수 있다.

*/