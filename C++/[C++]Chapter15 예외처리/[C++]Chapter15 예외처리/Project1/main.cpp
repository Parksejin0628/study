#include<iostream>

using std::cout;
using std::cin;
using std::endl;

int main(void)
{


	return 0;
}

/*
[Chatper15 예외처리(Exception Handling)]
<15.1. 예외상황과 예외처리의 이해>.
1. 예외(exception)
 1) 예외란?
	- 예외(exception)란 프로그램 실행 도중 문법적인 에러가 아닌 프로그램의 논리에 맞지 않는 상황을 의미한다.
		ex) cout<<a/b : ;가 빠졌지만 문법적인 에러기에 C++에서 말하는 예외가 아니다.
		ex) b=0, cout<<a/b; : 0으로 나누는 것은 불가능하지만 문법적인 에러가 아니기에 C++에서 말하는 예외이다.
		ex) 프로그래머가 a, b모두 양수인 것을 의도했지만 음수값이 들어오는 경우 프로그램의 논리(의도)와 다르기에 C++에서 말하는 예외이다.
2. 예외를 처리하는 방법
 1) if문을 통한 처리 방법
	- if문을 통해 논리적 오류가 있는지 찾는 방법이다.
		ex) a가 양수만 들어오기를 원할 때 if(a>=0) { cout<<"error"<<endl; } 이런식으로 논리적 오류를 검출해내는 것이다.
	- 문제점 : 해당 if문이 프로그램 흐름을 구성하는 코드인지, 단순 예외처리를 위한 코드인지 한 눈에 파악이 불가능하다.
		> 즉, 가독성이 떨어지고 이로인해 유지보수성이 떨어진다.
 2) try-catch-throw 처리 방법
	- try, catch, throw 키워드를 사용한 예외처리 방법이다.
	- C++에서 제공하는 예외처리 메커니즘이다.
	- if문을 통한 처리방법의 단점인 가독성과 유지보수성을 향상시킬 수 있다. 
		> try, catch, throw 키워드만 보아도 이 코드가 예외처리를 위한 코드인지 바로 파악이 가능하기 때문이다.

<15.2. C++의 예외처리 매커니즘>
1. 예외처리의 핵심 키워드
 1) try : 예외를 검사할 범위를 지정
	- 예외 발생을 검출할 코드의 범위를 지정한다. {}블록안에 코드 안에서 예외가 발생하면 (throw가 발생하면) catch문장을 실행시킨다.
		ex) try
			{
				코드...			<< 이 코드에서 예외 발생시 catch안에 있는 문장을 실행시킨다.
			}
 2) catch : 예외를 처리하는 코드
	- 예외 발생시 대처하는 코드가 있는 곳이다. {}블록안에 예외 발생시 처리할 코드를 넣는다. 예외 발생시 catch안에 있는 코드가 실행된다.
	- catch문에 들어가는 데이터는 마치 함수처럼 데이터의 복제본을 catch문장 안에서 사용할 수 있도록 해준다.
		ex) catch(예외와 관련된 데이터)
			{
				예외처리와 관련된 코드...
			}
	- 반드시 try문 바로 뒤에 있어야한다. try문과 catch문 사이에 어떤 문장이라도 있으면 컴파일에러가 발생한다.
		ex) try
			{
				코드
			}
			cout<<"끼어들기!"<<endl;		<<이 문장으로 인해 에러가 발생한다. 이 문장을 삭제해야 에러가 발생하지 않는다.
			catch(예외와 관련된 데이터)
			{
				예외처리 코드
			}
 3) throw : 예외 발생을 알림
	- 예외가 발생했음을 프로그램에 알리고 예외와 관련된 데이터를 catch문으로 전달한다.
	- 즉, throw문이 실행되면 catch문이 실행되는 것이다.
		ex) try안에서 throw a; 가 발생하면 catch(int exn){ ... } 문장이 실행된다.
2. 예외처리 과정에서의 코드흐름
 1) 예외발생시 코드 흐름
	- try안에 문장을 실행시킨다.
	- throw로 인해 예외가 발생함을 인지한다.
	- 즉시, try안에 문장을 중단시키고 catch문장을 실행시킨다.
	- catch문 이후 문장을 실행시킨다.
	- 즉, 예외발생시 마치 반복문의 break;처럼 try안에 문장을 중단시키며 되돌아가지 않는다.
 2) 전반적인 예외처리 과정에서의 코드 흐름
	- try 블록을 만나면 그 안에 코드를 순서대로 실행한다.
	- 예외가 발생하지 않는다면 try 안에 코드를 모두 끝낸 후 catch이후 문장을 실행한다.
	- 예외가 발생하면 try 안에 코드를 예외발생 지점에서 중단한 후 catch문장을 실행한다. 그 후 catch이후 문장을 실행한다.

<15.3. Stack Unwinding(스택 풀기)>
1. 예외의 전달
 1) 예외의 전달
	- 하나의 함수에서 예외가 발생했으나 예외를 처리할 수 없는 경우 해당 예외는 해당 함수를 호출한 영역으로 전달된다.
		> 또한, 예외의 처리에 대한 책임도 함수를 호출한 영역으로 전달된다.
 2) 예외 전달의 특징
	- 예외를 처리할 수 없어 예외를 호출한 영역으로 전달할 경우 예외가 발생한 함수는 더 이상 실행되지 않고 종료된다. (반복문의 break, 함수의 return 처럼)
 3) 스택 풀기
	- 예외가 처리되지 않아 함수를 호출한 영역으로 예외 데이터가 전달되는 현상을 가리켜 '스택 풀기(Stack Unwinding)'이라고 한다.
	- 예외가 처리될 때까지 호출된 함수의 역순으로 예외 데이터가 계속해서 전달되는 현상이다.
	- 이러한 이름이 붙은 이유는 예외를 전달하면서 해당 함수가 종료되고, 예외를 전달한 함수의 스택이 반환되기 때문에 이러한 이름이 붙게 되었다.
	- 스택 풀기를 진행하다가 main 함수에서도 예외가 처리되지 않는다면, terminate 함수가 호출되면서 프로그램이 종료된다.
		> terminate 함수는 프로그램을 종료시키는 함수이다.
 4) 자료형 미일치
	- 만약, try-catch 문이 존재해도 catch의 매개변수 자료형이 전달된 예외의 자료형과 다르다면 예외 처리가 되지 않고 스택풀기를 진행한다.
2. 하나의 예외, 다수의 처리
 1) 하나의 try, 다수의 catch
	- 하나의 try 블록 내에서 다수의 예외가 발생할 수 있고, 이 예외의 자료형이 다를 수 있기 때문에 하나의 try에 다수의 catch문을 쓰는 것을 허용한다.
		ex) try { ... } catch(int num){ ... } catch(char str) { ... }
			> 이 경우 try 블록 내에서 int형 예외가 발생하면 첫 번째 catch문이, char형 예외가 발생하면 두 번째 catch 문이 실행된다.
 2) 전달되는 예외 명시
	- 함수를 정의할 때 발생 가능한 예외를 명시할 수 있다.
		ex) int ThrowFunc(int num) throw (int, char)
	- 이렇게 예외를 명시할 경우 명시한 자료형을 제외한 예외가 명시된다면 프로그램을 종료시킨다.
		> 예외를 명시했음에도 다른 자료형이 나왔다는 것은 프로그래머의 실수라는 의미이고 이를 스택풀기를 진행하며 실행하는 것보다 프로그램을 종료시켜 확실하게 재점검하도록 유도하는 것이 더 프로그래머에게 유리하기 때문이다.
	- 이렇게 명시를 할 경우 함수의 정의만 보아도 적절한 try-catch문을 확인할 수 있기 때문에 유지/보수 면에서 유리하다고 볼 수 있다.
	- throw () 이런 식으로 명시할 경우 어떠한 예외도 허용하지 않는다는 의미이다. 따라서, 예외가 발생할 경우 프로그램을 종료시킨다.
		ex) int SimpleFunc(int num) throw ()

<15.4. 예외상황을 표현하는 예외 클래스의 설계>
1. 예외 클래스, 예외 객체
 1) 예외 객체 : 예외 발생을 알리는데 사용되는 객체
	ex) throw obj에서 obj가 객체인 경우 예외 객체가 되는 것이다.
	- 예외 객체는 굳이 복사할 필요가 없기에 참조자로써 받으면 좋다.
		ex) catch(Exception &expn)
	- 예외 객체는 C++의 예외처리 메커니즘에 의해 처리되기 때문에 코드상에서 직접 참조할 필요가 없다. 따라서, 임시 객체로 생성하는 것이 보통이다.
		ex) throw Exception(information)  < 여기서 Exception자체가 클래스 명이다. 따라서, 임시 객체이다.
 2) 예외 클래스 : 예외 객체로써 사용하기 위해 정의된 클래스이다.
	- 예외에 대한 정보를 담을 수 있다는 장점이 있다.
	- 예외상황을 잘 표현할 수 있도록 정의하되 너무 복잡하지 않게 정의하는 것이 좋다.
	- 예외의 표현을 위한 최소한의 기능만 담아서 정의하면 좋다.
2. 예외 클래스의 특징
 1) 예외 클래스끼리의 상속
	- 예외 클래스끼리도 상속을 이룰 수 있다.
	- 상속을 이룸으로써 예외의 처리를 단순화 할 수 있다.
		ex) Exception 클래스가 있고 이 클래스를 상속하는 AAAException, BBBException이 있다고 가정하면 catch문에는 Exception을 정의해놓고 상황에 따라 AAAException, BBBException을 보내면 된다.
			catch(Exception &expn)
 2) 예외 클래스를 사용해 catch문을 연속으로 사용할 때 주의할 점
	- 하나의 try 문에 여러개의 catch문을 사용할 경우 항상 코드상 상단에 있는 catch문부터 자료형과 catch문이 일치하는지 확인한다.
	- 따라서, 상속을 사용할 때 기초클래스를 먼저 catch할 경우 유도클래스를 throw해도 유도클래스를 catch하는 곳에 도달할 수 없다.
		ex) AAA가 기초, BBB와 CCC가 유도클래스라고 가정하자.
			catch(Expn AAA) { ... }
			catch(Expn BBB) { ... }
			catch(Expn CCC) { ... } 
			이 문장에서 AAA, BBB, CCC는 모두 catch(Expn AAA)에서 걸리게 된다.
			따라서, BBB, CCC에 대한 예외처리를 따로 하기 위해서는
			catch(Expn BBB) { ... }
			catch(Expn CCC) { ... }
			catch(Expn AAA) { ... } 
			이런식으로 기초클래스를 뒤로 보내야 한다.
*/