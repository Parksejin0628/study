#include<iostream>

using std::cout;
using std::cin;
using std::endl;

int main(void)
{


	return 0;
}

/*
[Chapter15 예외처리(Exception Handling)]
<15.1. 예외상황과 예외처리의 이해>
1. 예외 : 문법적인 에러가 아닌 프로그램 논리에 맞지 않는 상황을 말한다.
2. if문을 통한 예외처리를 하면 if문이 조건문인지, 예외처리를 위한 코드인지 한 눈에 파악이 불가능하여 유지보수성이 떨어진다.
3. C++에서 제공하는 예외처리 메커니즘 try-catch-throw를 사용하면 if문과 다르게 예외처리를 위한 코드라는 것을 바로 파악이 가능하여 유지보수성을 향상시킬 수 있다.

<15.2. C++의 예외처리 메커니즘>
1. 예외처리의 핵심 키워드
	- try : {}블록 안에서 예외가 발생하면 try 블록안에 문장을 중단시키고 catch문을 실행시킨다.
	- catch : 예외발생시 처리하는 코드를 담는다. 예외와 관련된 데이터를 함수의 매개변수처럼 받는다.
	- throw : 예외가 발생한 것을 알려 catch문을 실행하도록 한다. catch문에 예외와 관련된 데이터를 보낸다.
	ex)
	try
	{
		...
		throw exceptionData;
		...
	}
	catch(int data)
	{
		...
	}
2. 예외처리 과정의 흐름
	try문 실행 > throw문을 통해 예외발생을 인지>try문 중단 > catch문 실행 > catch문 이후 코드 실행
3. 예외처리 주의점
	- try{ ... } 바로 뒤에 catch(){ ... }가 와야한다.
	- 예외발생시 남은 try문 뒤를 실행하지 않는다.

<15.3. Stack Unwinding(스택 풀기)>
1. Stack Unwinding : 함수에서 예외가 발생했으나 함수안에 예외처리가 없을 경우 함수를 즉시 중단하고 함수를 호출한 곳으로 예외를 전달한다.
	- 예외를 전달하면서 함수 스택이 반환되기 때문에 이러한 이름이 붙었다.
	- main함수에서도 예외처리가 안된다면 프로그램을 종료시키는 terminate 함수가 호출된다.
	- throw의 자료형과 catch의 자료형이 다른다면 예외를 처리할 수 없는 것으로 판단한다.
2. 하나의 try 블록 뒤에 다수의 catch문을 짤 수 있다.
	- 여러 자료형에 대응할 수 있게 된다.
3. 함수 정의 뒤에 throw(자료형1, 자료형2, ...)을 작성하여 예외를 명시할 수 있다.
	- 명시한 자료형 외의 자료형이 예외로 전달되면 프로그램을 종료시킨다.
	- 프로그램의 실수를 방지하고 어떤 예외가 발생하는지 한 눈에 알아볼 수 있어 유지보수성도 늘어난다.

<15.4. 예외상황을 표현하는 예외 클래스의 설계>
1. 예외 객체 : 예외 발생을 알리는데 사용하는 객체이다.
	- 보통은 참조자 형태로, 클래스 명을 직접 사용하여 임시 객체의 형태로 사용한다.
2. 예외 클래스 : 예외 객체로 사용하기 위해 정의된 클래스이다.
	- 예외에 대한 정보를 담을 수 있다.
	- 상속을 통해 예외의 처리를 단순화 할 수 있다.
		ex) catch는 기초클래스로 받게한 뒤 상황에 따른 유도클래스를 throw하면 유연성이 늘어난다.
3. 상속을 이용한 예외 클래스를 이용할 떄는 가장 위에 있는 catch문을 먼저 검사한다는 점을 유의하여 유도클래스를 사용한 catch문을 위에, 기초클래스를 사용한 catch문을 밑에 두어야 한다.

<15.5. 예외처리와 관련된 또 다른 특성들>
1. new연산자가 메모리 공간 할당을 실패할 경우 bad_alloc이라는 예외를 전달한다.
	- 이를 catch하여 예외를 처리할 수 있다.
2. catch(...)로 선언하면 try블록 내에 모든 예외를 받을 수 있다.
	- 보통 catch문 마지막에 사용한다.
3. catch문 안에서 throw;를 사용할 경우 함수를 호출한 영역으로 예외를 전달한다.


*/

/*
[Chatper15 예외처리(Exception Handling)]
<15.1. 예외상황과 예외처리의 이해>.
1. 예외(exception)
 1) 예외란?
	- 예외(exception)란 프로그램 실행 도중 문법적인 에러가 아닌 프로그램의 논리에 맞지 않는 상황을 의미한다.
		ex) cout<<a/b : ;가 빠졌지만 문법적인 에러기에 C++에서 말하는 예외가 아니다.
		ex) b=0, cout<<a/b; : 0으로 나누는 것은 불가능하지만 문법적인 에러가 아니기에 C++에서 말하는 예외이다.
		ex) 프로그래머가 a, b모두 양수인 것을 의도했지만 음수값이 들어오는 경우 프로그램의 논리(의도)와 다르기에 C++에서 말하는 예외이다.
2. 예외를 처리하는 방법
 1) if문을 통한 처리 방법
	- if문을 통해 논리적 오류가 있는지 찾는 방법이다.
		ex) a가 양수만 들어오기를 원할 때 if(a>=0) { cout<<"error"<<endl; } 이런식으로 논리적 오류를 검출해내는 것이다.
	- 문제점 : 해당 if문이 프로그램 흐름을 구성하는 코드인지, 단순 예외처리를 위한 코드인지 한 눈에 파악이 불가능하다.
		> 즉, 가독성이 떨어지고 이로인해 유지보수성이 떨어진다.
 2) try-catch-throw 처리 방법
	- try, catch, throw 키워드를 사용한 예외처리 방법이다.
	- C++에서 제공하는 예외처리 메커니즘이다.
	- if문을 통한 처리방법의 단점인 가독성과 유지보수성을 향상시킬 수 있다. 
		> try, catch, throw 키워드만 보아도 이 코드가 예외처리를 위한 코드인지 바로 파악이 가능하기 때문이다.

<15.2. C++의 예외처리 매커니즘>
1. 예외처리의 핵심 키워드
 1) try : 예외를 검사할 범위를 지정
	- 예외 발생을 검출할 코드의 범위를 지정한다. {}블록안에 코드 안에서 예외가 발생하면 (throw가 발생하면) catch문장을 실행시킨다.
		ex) try
			{
				코드...			<< 이 코드에서 예외 발생시 catch안에 있는 문장을 실행시킨다.
			}
 2) catch : 예외를 처리하는 코드
	- 예외 발생시 대처하는 코드가 있는 곳이다. {}블록안에 예외 발생시 처리할 코드를 넣는다. 예외 발생시 catch안에 있는 코드가 실행된다.
	- catch문에 들어가는 데이터는 마치 함수처럼 데이터의 복제본을 catch문장 안에서 사용할 수 있도록 해준다.
		ex) catch(예외와 관련된 데이터)
			{
				예외처리와 관련된 코드...
			}
	- 반드시 try문 바로 뒤에 있어야한다. try문과 catch문 사이에 어떤 문장이라도 있으면 컴파일에러가 발생한다.
		ex) try
			{
				코드
			}
			cout<<"끼어들기!"<<endl;		<<이 문장으로 인해 에러가 발생한다. 이 문장을 삭제해야 에러가 발생하지 않는다.
			catch(예외와 관련된 데이터)
			{
				예외처리 코드
			}
 3) throw : 예외 발생을 알림
	- 예외가 발생했음을 프로그램에 알리고 예외와 관련된 데이터를 catch문으로 전달한다.
	- 즉, throw문이 실행되면 catch문이 실행되는 것이다.
		ex) try안에서 throw a; 가 발생하면 catch(int exn){ ... } 문장이 실행된다.
2. 예외처리 과정에서의 코드흐름
 1) 예외발생시 코드 흐름
	- try안에 문장을 실행시킨다.
	- throw로 인해 예외가 발생함을 인지한다.
	- 즉시, try안에 문장을 중단시키고 catch문장을 실행시킨다.
	- catch문 이후 문장을 실행시킨다.
	- 즉, 예외발생시 마치 반복문의 break;처럼 try안에 문장을 중단시키며 되돌아가지 않는다.
 2) 전반적인 예외처리 과정에서의 코드 흐름
	- try 블록을 만나면 그 안에 코드를 순서대로 실행한다.
	- 예외가 발생하지 않는다면 try 안에 코드를 모두 끝낸 후 catch이후 문장을 실행한다.
	- 예외가 발생하면 try 안에 코드를 예외발생 지점에서 중단한 후 catch문장을 실행한다. 그 후 catch이후 문장을 실행한다.

<15.3. Stack Unwinding(스택 풀기)>
1. 예외의 전달
 1) 예외의 전달
	- 하나의 함수에서 예외가 발생했으나 예외를 처리할 수 없는 경우 해당 예외는 해당 함수를 호출한 영역으로 전달된다.
		> 또한, 예외의 처리에 대한 책임도 함수를 호출한 영역으로 전달된다.
 2) 예외 전달의 특징
	- 예외를 처리할 수 없어 예외를 호출한 영역으로 전달할 경우 예외가 발생한 함수는 더 이상 실행되지 않고 종료된다. (반복문의 break, 함수의 return 처럼)
 3) 스택 풀기
	- 예외가 처리되지 않아 함수를 호출한 영역으로 예외 데이터가 전달되는 현상을 가리켜 '스택 풀기(Stack Unwinding)'이라고 한다.
	- 예외가 처리될 때까지 호출된 함수의 역순으로 예외 데이터가 계속해서 전달되는 현상이다.
	- 이러한 이름이 붙은 이유는 예외를 전달하면서 해당 함수가 종료되고, 예외를 전달한 함수의 스택이 반환되기 때문에 이러한 이름이 붙게 되었다.
	- 스택 풀기를 진행하다가 main 함수에서도 예외가 처리되지 않는다면, terminate 함수가 호출되면서 프로그램이 종료된다.
		> terminate 함수는 프로그램을 종료시키는 함수이다.
 4) 자료형 미일치
	- 만약, try-catch 문이 존재해도 catch의 매개변수 자료형이 전달된 예외의 자료형과 다르다면 예외 처리가 되지 않고 스택풀기를 진행한다.
2. 하나의 예외, 다수의 처리
 1) 하나의 try, 다수의 catch
	- 하나의 try 블록 내에서 다수의 예외가 발생할 수 있고, 이 예외의 자료형이 다를 수 있기 때문에 하나의 try에 다수의 catch문을 쓰는 것을 허용한다.
		ex) try { ... } catch(int num){ ... } catch(char str) { ... }
			> 이 경우 try 블록 내에서 int형 예외가 발생하면 첫 번째 catch문이, char형 예외가 발생하면 두 번째 catch 문이 실행된다.
 2) 전달되는 예외 명시
	- 함수를 정의할 때 발생 가능한 예외를 명시할 수 있다.
		ex) int ThrowFunc(int num) throw (int, char)
	- 이렇게 예외를 명시할 경우 명시한 자료형을 제외한 예외가 명시된다면 프로그램을 종료시킨다.
		> 예외를 명시했음에도 다른 자료형이 나왔다는 것은 프로그래머의 실수라는 의미이고 이를 스택풀기를 진행하며 실행하는 것보다 프로그램을 종료시켜 확실하게 재점검하도록 유도하는 것이 더 프로그래머에게 유리하기 때문이다.
	- 이렇게 명시를 할 경우 함수의 정의만 보아도 적절한 try-catch문을 확인할 수 있기 때문에 유지/보수 면에서 유리하다고 볼 수 있다.
	- throw () 이런 식으로 명시할 경우 어떠한 예외도 허용하지 않는다는 의미이다. 따라서, 예외가 발생할 경우 프로그램을 종료시킨다.
		ex) int SimpleFunc(int num) throw ()

<15.4. 예외상황을 표현하는 예외 클래스의 설계>
1. 예외 클래스, 예외 객체
 1) 예외 객체 : 예외 발생을 알리는데 사용되는 객체
	ex) throw obj에서 obj가 객체인 경우 예외 객체가 되는 것이다.
	- 예외 객체는 굳이 복사할 필요가 없기에 참조자로써 받으면 좋다.
		ex) catch(Exception &expn)
	- 예외 객체는 C++의 예외처리 메커니즘에 의해 처리되기 때문에 코드상에서 직접 참조할 필요가 없다. 따라서, 임시 객체로 생성하는 것이 보통이다.
		ex) throw Exception(information)  < 여기서 Exception자체가 클래스 명이다. 따라서, 임시 객체이다.
 2) 예외 클래스 : 예외 객체로써 사용하기 위해 정의된 클래스이다.
	- 예외에 대한 정보를 담을 수 있다는 장점이 있다.
	- 예외상황을 잘 표현할 수 있도록 정의하되 너무 복잡하지 않게 정의하는 것이 좋다.
	- 예외의 표현을 위한 최소한의 기능만 담아서 정의하면 좋다.
2. 예외 클래스의 특징
 1) 예외 클래스끼리의 상속
	- 예외 클래스끼리도 상속을 이룰 수 있다.
	- 상속을 이룸으로써 예외의 처리를 단순화 할 수 있다.
		ex) Exception 클래스가 있고 이 클래스를 상속하는 AAAException, BBBException이 있다고 가정하면 catch문에는 Exception을 정의해놓고 상황에 따라 AAAException, BBBException을 보내면 된다.
			catch(Exception &expn)
 2) 예외 클래스를 사용해 catch문을 연속으로 사용할 때 주의할 점
	- 하나의 try 문에 여러개의 catch문을 사용할 경우 항상 코드상 상단에 있는 catch문부터 자료형과 catch문이 일치하는지 확인한다.
	- 따라서, 상속을 사용할 때 기초클래스를 먼저 catch할 경우 유도클래스를 throw해도 유도클래스를 catch하는 곳에 도달할 수 없다.
		ex) AAA가 기초, BBB와 CCC가 유도클래스라고 가정하자.
			catch(Expn AAA) { ... }
			catch(Expn BBB) { ... }
			catch(Expn CCC) { ... } 
			이 문장에서 AAA, BBB, CCC는 모두 catch(Expn AAA)에서 걸리게 된다.
			따라서, BBB, CCC에 대한 예외처리를 따로 하기 위해서는
			catch(Expn BBB) { ... }
			catch(Expn CCC) { ... }
			catch(Expn AAA) { ... } 
			이런식으로 기초클래스를 뒤로 보내야 한다.

<15.5. 예외처리와 관련된 또 다른 특성들>
1. new 연산자에 의해서 발생하는 예외
	1) new 연산에 의한 메모리 공간의 할다잉 실패하면 bad_alloc이라는 예외가 발생한다.
	2) bad_alloc을 catch해서 예외를 처리할 수 있다.
		ex) catch(bad_allco &bad)
2. 모든 예외를 처리하는 catch 블록
	1) catch(...)이런 식으로 catch 블록을 선언하면 try 블록 내의 모든 예외를 받을 수 있다.
	2) 단, 발생한 예외와 관련한 어떠한 정보, 예외의 종류를 파악할 수 없다.
	3) 보통 catch문 마지막에 덧붙여지는 경우가 많다.
		ex) catch(expn AAA) { ... }
			catch(expn BBB) { ... }
			...
			catch(...) { ... }
3. 예외 던지기
	1) catch문에 전달된 예외는 throw에 의해 다시 던져질 수 있다.
		ex) catch(expn AAA) 
			{ 
				...
				throw;		<< 이 문장에 의해 다시 던져진다.
			}
	2) 다시 던져진 예외는 함수를 호출한 영역으로 전달된다.
	3) 예외는 가급적 간결한 구조를 띄는 것이 좋기 때문에 정말 필요한 상황이 아니라면 굳이 할 필요가 없다.
*/