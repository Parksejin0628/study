#include"Person.h"
#include"common.h"
#include"Police.h"

//다음에 공부할 때는 배열 클래스의 형태를 실제로 만들어보고 문제 11-2를 풀이하면 된다.

void que1();

int main(void)
{
	Person man1("Lee dong woo", 29);
	Person man2("Yoon ji yul", 22);
	man2 = man1;
	man1.ShowPersonInfo();
	man2.ShowPersonInfo();

	que1();

	return 0;
}

void que1()
{
	/*
	[문제1]
	Chapter 07에서는 예제 HASCComposite.cpp를 통해서 다음의 두 클래스를 정의하였다.
	이 예제에서 Police 클래스를 대상으로 깊은 복사가 이뤄지도록 대입 연산자와 복사 생성자를 동시에 정의하고 
	확인을 위한 함수도 적절히 정의해보자.
	*/
	Police police1(2, 5);
	Police police2 = police1;

	cout << "오리지널 총 정보" << endl;
	police1.ShowPolice();
	cout << "복사생성자 police2 정보 확인" << endl;
	police2.ShowPolice();

	Police police3(5, 22);
	cout << "원래 police3 정보" << endl;
	police3.ShowPolice();
	police3 = police1;
	cout << "대입 후 police3 정보" << endl;
	police3.ShowPolice();

	return;
}

/*
[Chapter11 연산자 오버로딩2]
<11.1. 반드시 해야 하는 대입 연산자의 오버로딩>
1. 대입 연산자의 대표적인 특성 및 오버로딩
 1) 대입 연산자의 특성은 복사 생성자와 매우 유사하다.
	- 정의하지 않으면 디폴트 대입 연산자가 삽입된다.
	- 디폴트 대입 연산자는 멤버 대 멤버의 복사를 진행한다. (얕은 복사)
	- 깊은 복사가 필요한 경우 직접 정의해야 한다.
 2) 복사 생성자 호출과 다른 점은 이미 생성 및 초기화를 끝낸 객체들을 대상으로 진행한다.
	ex) obj2 = obj1 이 문장의 경우
		> obj1만 초기화가 끝난 객체인 경우 : 복사 생성자 호출
		> obj1, obj2 모두 초기화가 끝난 객체인 경우 : 대입 연산자 호출(오버로딩)
 3) 디폴트 대입 연산자는 멤버 대 멤버의 복사를 진행하며 호출한 객체를 참조형으로 반환한다.
	- 다른 연산자 오버로딩처럼 obj1 = obj2 는 obj1.operator=(obj2) 로 해석된다.
2. 디폴트 대입 연산자의 문제점 및 해결법
 1) 복사 생성자의 유사한 문제점이 존재한다.
	- 유사하게 얕은 복사가 진행되기에 참조형 변수를 복사할 때 서로 다른 객체가 같은 주소를 가리키게 되는 문제가 있다.
		> 즉, 동적할당을 하는 변수가 있을 경우 객체가 소멸할 때 같은 공간을 두 번 소멸하게 된다.
	- 이미 정의된 객체를 대상으로 복사가 이루어지기 때문에 기존에 가리키던 공간의 주소값을 잃게 된다.
		> 주소값을 잃은 공간은 다시 접근이 불가능하기에 소멸도 불가능하게 된다. 이는 메모리 누수로 이어진다.
 2) 복사 생성자의 문제를 해결하기 위해서는 복사 생성자의 문제를 해결할 때와 유사하게 접근해야 한다.
	- 따로 정의하여 깊은 복사를 진행하도록 해야 한다.
	- 복사를 진행하기 전 메모리 누수를 방지하기 위해 기존에 가리키던 공간의 메모리를 해제시켜야 한다.
3. 상속 구조에서의 대입 연산자 호출
 1) 대입 연산자는 복사 생성자와 다르게 유도 클래스에서 대입 연산자가 호출되어도 기초 클래스의 대입 연산자가 호출되지 않는다.
	- 이는 유도 클래스의 대입 연산자 부분에서 기초 클래스의 대입 연산자 호출을 따로 명시해야 한다는 의미이다.
	- 따로 명시하지 않을 경우 기초 클래스의 대입 연산자는 호출되지 않아 유도 클래스의 멤버만 복사되는 경우가 발생하낟.
4. 이니셜라이저가 성능 향상에 도움을 주는 이유
 1) 이니셜라이저는 생성과 동시에 초기화가 이루어진다.
	> 따라서, 초기화 과정에서 생성자만 호출된다.
 2) 단순한 대입 연산자를 통한 초기화는 생성과 초기화가 따로 이루어진다.
	- 즉, 선언과 초기화를 별도의 문장에서 진행하는 형태로 이루어진다.
	- 이는 선언을 할 때 생성자가, 초기화를 할 때 대입 연산자가 호출되어 함수를 2번 이상 호출하게 한다.
 3) 위 같은 이유 때문에 이니셜라이저를 이용하면 함수의 호출 횟수가 줄어들어 성능향상이 된다.
<11.2. 배열의 인덱스 연산자 오버로딩>
1. 배열의 인덱스 연산자 오버로딩 및 배열 클래스
 1) []연산자도 다른 연산자와 비슷하게 연산자 오버로딩이 된다.
	ex) obj[2] -> obj.operator[](2)로 해석이 된다.
	- []연산자는 멤버함수 기반으로만 오버로딩 할 수 있다.
 2) C, C++의 기본 배열은 경계검사를 실시하지 않는다는 단점을 가지고 있다.
	- 즉, arr[3]으로 정의한 변수에 arr[-1], arr[4]등 범위를 넘게 접근해도 이상 없이 컴파일 된다.
 3) 기본 배열의 단점을 보완하는 멤버 함수를 지닌 배열 클래스가 필요한 이유이다.
	- 배열 클래스의 기본적인 형태는 코드부분 arr 클래스에서 다룬다.
 4) []연산자 오버로딩에서 반환형태를 참조형으로 함으로써 배열 값의 변경을 허용한다.
	ex) 'int& operator[](int idx)' 형식처럼 하여 'obj[2] = 3'과 같은 문장이 허용되도록 한다.(기존 배열처럼 사용을 위해)
 5) 객체를 대상으로 하는 복사 생성자와 대입 연산자를 private 멤버로 두어 복사와 대입을 원천적으로 막는것이 좋다.
	- 배열은 유일성이 보장될 필요가 있기 때문이다.
2. const 오버로딩 활용하기
 1) const함수에서도 객체 클래스 값에 접근해야 하는 경우가 있다.
	- 그러나, 연산자 오버로딩이 const가 아니기에 접근할 수 없다.
 2) 기존 연산자 오버로딩 함수를 const로 선언하면 값의 변화가 불가능해진다.
	ex) 'obj[2] = 3'과 같은 문장은 멤버의 값을 변화시키기에 const 선언과 맞지 않는다.
 3) 따라서, const함수를 위한 const 오버로딩을 해둘 필요가 있다.
	- 이미 앞에서 const의 유무 만으로 오버로딩이 가능함을 익혔다.
	- 이때 'int operator[](int idx) const'와 같이 참조형이 아닌 값을 반환한다.
		> 값의 변화는 어차피 허용되지 않기 때문이다.
	- 이와 관련된 코드는 코드부분의 arr부분에서 다루고 있다.
3. 객체를 저장하는 배열 클래스
 1) 객체를 저장하는 배열 기반의 클래스
	- 객체 자체를 멤버 변수에 저장하는 방법이다.
	- 배열을 초기화 할 때 대입연산을 사용해야 하기 때문에 복사 생성자와 대입 연산자의 얕은 복사를 신경써야 하는 단점이 있다.
 2) 주소값을 저장하는 배열 기반의 클래스
	- 객체의 주소값을 멤버 변수에 저장하는 방법이다.
	- new, delete를 신경써야 하지만 복사 생성자와 대입 연산자의 얕은 복사를 신경쓸 필요가 없다.
	- 위와 같은 장점으로 객체를 저장하는 방법보다 많이 쓰인다.
 3) 형태 : 코드 부분의 objArr부분에서 다룬다.
*/