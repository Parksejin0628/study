#include<iostream>

using std::cin;
using std::cout;
using std::endl;


int main(void)
{
	

	return 0;
}

/*
[Chapter09 가상(Virtual)의 원리와 다중상속]
<9.1. 멤버함수와 가상함수의 동작원리>
1. 멤버함수가 실제로 존재하는 위치
 1) 실제 멤버함수는 객체 내에 존재하지 않는다. 하지만, 앞으로도 개념적으로 객체 안에 멤버함수가 존재한다고 인식하는 것이 좋다.
 2) 멤버 함수는 별도의 메모리 공간에 위치하고, 이를 모든 객체가 공유하는 형태를 취한다.
	> 멤버 변수는 객체가 생성되면 객체 내에 존재한다.
	> 멤버 함수는 객체가 필요할 때 마다 호출하는 형식으로 사용이 된다.
2. 가상함수의 동작원리 (virtual)
 1) 가상함수 테이블 : 클래스 내에 한 개 이상의 가상함수가 존재할 경우, 컴파일러는 '가상함수 테이블'이라는 것을 만든다.
	ex) key					value
		void AAA:Func1()	0x1024
		void AAA:Func2()	0x2048
 2) 가상함수 테이블은 실제 호출되어야 하는 함수의 위치정보(포인터값, 위 표에서는 value)를 담고 있는 테이블이다.
	> 가상함수 테이블을 가리키는 주소값이 객체 내에 저자아되지만, 개발자가 참조할 수 없는 값이다.
		ex) vtable ptr  << 가상테이블을 가리키는 보이지않는 값
 3) 만약 유도클래스에서 오버라이딩된 가상함수가 있다면, 기초클래스의 해당 가상함수 위치값은 유도클래스의 가상함수 테이블에 존재하지 않는다.
	ex) AAA를 상속하는 BBB의 가상함수 테이블값 (Func1()이 오버라이딩 되었음)
		key					value
		void BBB:Func1()	0x3072	<< BBB에서 오버라이딩 되었기 때문에 AAA:Func1()의 위치값은 테이블에 존재하지 않는다. 따라서, BBB에서는 AAA:Func1()를 일반적으로 호출하지 않는다.
		void AAA:Func2()	0x2048  << BBB에서 오버라이딩이 안됐기 때문에 AAA:Func2()의 위치값을 받아온다.
		void BBB:Func3()	0x4096  << BBB에서 새로 추가된 함수이다.
 4) 이러한 원리로 오버라이딩된 경우 기초클래스의 함수 위치값을 받지 않아 마지막에 오버라이딩한 유도 클래스의 멤버 함수가 호출되는 것이다.
 5) 위 가상함수 테이블의 존재가 C++이 C보다 느린 이유가 된다.
	> 가상함수가 하나라도 존재하면 객체에서 함수를 바로 호출하는 것이 아닌 가상함수 테이블을 한 번 거쳐야 하기 때문에 상대적으로 속도가 느리다.
	> 하지만, 속도 차이가 미미하고 이러한 단점에 비해 얻게되는 장점이 많기 때문에 가상함수가 유용하게 활용되는 것이다.
<9.2. 다중상속(Multiple Inheritance)에 대한 이해>
 1. 다중상속이란?
  1) 다중상속 : 둘 이상의 클래스를 동시에 상속하는 것이다.
  2) 사용방법 : 상속을 할 때 쉼표를 이용해 상속의 대상이 되는 클래스를 나열한다.
	ex) class AAA : public BBB, protected CCC { ... };
 2. 다중상속의 문제점
  1) 다중상속은 여러 문제로 논란이 되는 문법이다. 많은 프로그래머들이 득보다 실이 많고 다양한 문제를 동반하는 등 가급적 사용해선 안된다고 주장한다.
  2) 문제점1 : 다중상속의 대상이 되는 두 기초 클래스에 동일한 이름의 멤버가 존재하는 경우
	> 컴파일러는 어느 기초 클래스의 멤버를 가져와야 하는지 알 수 없으므로 문제가 발생한다.
	> 해결방법 : 어느 기초클래스에서 정의된 멤버를 가져올 것인지 명시한다.
		ex) BBB::SimpleFunc(); CCC::SimpleFunc();
  3) 문제점2 : 다중상속의 대상이 되는 두 기초 클래스가 같은 클래스를 상속할 경우 이중 상속이 된다.
	ex) BBB, CCC 모두 DDD를 상속하는 경우 AAA는 BBB, CCC로 부터 DDD를 간접적으로 상속받아 두 번 상속하게 된다.
		> 이 경우 DDD의 함수를 그냥 호출할 수 없고 BBB, CCC를 명시해서 간접적으로 호출해야 한다.
			ex) BBB::DDDFunc();
	> 해결방법 : 가상 상속을 이용한다.
		ex) class BBB : virtual public DDD / class CCC : virtual public DDD / class AAA : BBB, CCC
			> 이런 식으로 할 경우 AAA는 DDD를 한 번만 상속받을 수 있게 된다.
*/